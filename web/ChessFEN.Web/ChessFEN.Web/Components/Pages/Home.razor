@page "/"
@using System.Text.Json
@inject HttpClient Http
@inject IConfiguration Configuration
@inject ILogger<Home> Logger
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

<PageTitle>Chess FEN Scanner</PageTitle>

<div class="container">
    <h1 class="text-center mb-4">♔ Chess FEN Scanner</h1>
    
    <div class="row">
        <!-- Left: Image Upload/Capture -->
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5>📷 Capture or Upload Image</h5>
                </div>
                <div class="card-body">
                    <!-- File Upload -->
                    <div class="mb-3">
                        <label class="form-label">Upload chess board image:</label>
                        <InputFile OnChange="HandleFileSelected" class="form-control" accept="image/*" />
                    </div>
                    
                    <!-- Camera Capture with overlay guide -->
                    <div class="mb-3">
                        <label class="form-label">Or capture from camera:</label>
                        <button type="button" class="btn btn-outline-secondary w-100" @onclick="OpenCameraCapture">
                            📸 Open Camera with Guide
                        </button>
                    </div>
                    
                    <!-- Preview -->
                    @if (hasImage)
                    {
                        <div class="text-center mb-3">
                            @if (!string.IsNullOrEmpty(imagePreview) && imagePreview != "pending")
                            {
                                <img src="@imagePreview" alt="Preview" class="img-fluid" style="max-height: 300px;" />
                            }
                            else if (selectedFile != null)
                            {
                                <div class="alert alert-info">
                                    📁 File selected: @selectedFile.Name (@(selectedFile.Size / 1024) KB)
                                    <br/><small>Click "Analyze Board" to process</small>
                                </div>
                            }
                            else
                            {
                                <div class="alert alert-info">
                                    📷 Camera image captured
                                    <br/><small>Click "Analyze Board" to process</small>
                                </div>
                            }
                        </div>
                    }
                    
                    <!-- Model Selection (Debug) -->
                    @if (debugMode)
                    {
                        <div class="mb-3">
                            <label class="form-label">Model:</label>
                            <select class="form-select" @bind="selectedModel">
                                @foreach (var model in availableModels)
                                {
                                    <option value="@model.Name">@model.Name (@model.Type) - @model.Accuracy</option>
                                }
                            </select>
                        </div>
                    }
                    
                    <!-- Skip Detection Option -->
                    <div class="form-check mb-3">
                        <input class="form-check-input" type="checkbox" id="skipDetection" 
                               checked="@skipDetection" 
                               @onchange="@((ChangeEventArgs e) => { skipDetection = (bool)(e.Value ?? false); StateHasChanged(); })">
                        <label class="form-check-label" for="skipDetection">
                            📐 Image is board only (skip detection)
                        </label>
                        <div class="form-text small">Use this when the image is a cropped chess board with no borders</div>
                    </div>
                    
                    <!-- Predict Button -->
                    @if (isLoading)
                    {
                        <button type="button" class="btn btn-primary btn-lg w-100" disabled>
                            <span class="spinner-border spinner-border-sm me-2"></span>
                            🔍 Analyzing...
                        </button>
                    }
                    else if (!hasImage)
                    {
                        <button type="button" class="btn btn-primary btn-lg w-100" disabled>
                            🔍 Analyze Board
                        </button>
                    }
                    else
                    {
                        <button type="button" class="btn btn-primary btn-lg w-100" @onclick="OnAnalyzeClick">
                            🔍 Analyze Board
                        </button>
                    }
                    
                    <!-- Test Button -->
                    <button type="button" class="btn btn-warning mt-2 w-100" @onclick="TestClick">
                        🧪 Test Click (Counter: @testCounter)
                    </button>
                    
                    <!-- Button state debug -->
                    <div class="small text-muted mt-1">
                        Button disabled: @buttonDisabled | File selected: @hasImage | Loading: @isLoading
                    </div>
                    
                    <!-- Debug Toggle -->
                    <div class="form-check mt-3">
                        <input type="checkbox" class="form-check-input" id="debugMode" @bind="debugMode" @bind:after="LoadModels" />
                        <label class="form-check-label" for="debugMode">Debug Mode</label>
                    </div>
                    
                    <!-- Debug Log Panel -->
                    @if (debugLogs.Count > 0)
                    {
                        <div class="mt-3">
                            <label class="form-label fw-bold">Debug Log:</label>
                            <div class="debug-log bg-dark text-light p-2" style="max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;">
                                @foreach (var log in debugLogs)
                                {
                                    <div>@log</div>
                                }
                            </div>
                            <button class="btn btn-sm btn-outline-secondary mt-1" @onclick="() => debugLogs.Clear()">Clear Log</button>
                        </div>
                    }
                </div>
            </div>
        </div>
        
        <!-- Right: Results -->
        <div class="col-md-6">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5>📋 Result</h5>
                    @if (!string.IsNullOrEmpty(resultFen))
                    {
                        <button class="btn btn-sm btn-outline-secondary" @onclick="CopyFen">
                            📋 Copy FEN
                        </button>
                    }
                </div>
                <div class="card-body">
                    @if (!string.IsNullOrEmpty(errorMessage))
                    {
                        <div class="alert alert-danger">
                            @errorMessage
                            @if (errorMessage.Contains("detect") || errorMessage.Contains("board"))
                            {
                                <hr class="my-2" />
                                <button class="btn btn-sm btn-warning" @onclick="CheckGridAlignment" disabled="@isCheckingAlignment">
                                    @if (isCheckingAlignment)
                                    {
                                        <span class="spinner-border spinner-border-sm me-1"></span>
                                    }
                                    🔍 Check Grid Alignment
                                </button>
                                <small class="d-block mt-1 text-muted">Analyze piece positions to help align the grid</small>
                            }
                        </div>
                    }
                    
                    @* Grid Alignment Result *@
                    @if (alignmentResult != null)
                    {
                        <div class="alert @(alignmentResult.Aligned ? "alert-success" : "alert-warning") py-2 mb-3">
                            <strong>Grid Alignment Check:</strong>
                            <p class="mb-1">@alignmentResult.Suggestion</p>
                            @if (alignmentResult.PieceFound)
                            {
                                <small>
                                    Piece detected in @alignmentResult.SquareName
                                    (confidence: @(alignmentResult.Confidence.ToString("P0")))
                                    @if (alignmentResult.Offset != null && alignmentResult.Offset.Count >= 2)
                                    {
                                        <text>, offset: (@alignmentResult.Offset[0]:F0, @alignmentResult.Offset[1]:F0)px</text>
                                    }
                                </small>
                            }
                            @if (!string.IsNullOrEmpty(alignmentResult.Overlay))
                            {
                                <div class="mt-2">
                                    <img src="data:image/png;base64,@alignmentResult.Overlay" class="img-fluid" style="max-width: 400px;" />
                                </div>
                            }
                        </div>
                    }
                    
                    @if (!string.IsNullOrEmpty(resultFen))
                    {
                        <!-- FEN String -->
                        <div class="mb-3">
                            <label class="form-label fw-bold">FEN (piece placement):</label>
                            <input type="text" class="form-control font-monospace" value="@resultFen" readonly />
                        </div>
                        
                        <!-- Full FEN for chess apps -->
                        <div class="mb-3">
                            <label class="form-label fw-bold">Full FEN (for chess apps):</label>
                            <div class="input-group mb-2">
                                <span class="input-group-text">White to move</span>
                                <input type="text" class="form-control font-monospace" value="@GetFullFen("w")" readonly id="fenWhite" />
                                <button class="btn btn-outline-primary" type="button" onclick="copyFenFromInput('fenWhite', this)">
                                    📋 Copy
                                </button>
                            </div>
                            <div class="input-group">
                                <span class="input-group-text">Black to move</span>
                                <input type="text" class="form-control font-monospace" value="@GetFullFen("b")" readonly id="fenBlack" />
                                <button class="btn btn-outline-primary" type="button" onclick="copyFenFromInput('fenBlack', this)">
                                    📋 Copy
                                </button>
                            </div>
                        </div>
                        
                        <!-- Analyze on Chess.com -->
                        <div class="mb-3">
                            <label class="form-label fw-bold">♟️ Analyze on Chess.com:</label>
                            <div class="d-flex gap-2 flex-wrap align-items-center">
                                <a href="@GetChessComAnalysisUrl("w")" target="_blank" class="btn btn-primary btn-sm">
                                    ♔ White to move
                                </a>
                                <a href="@GetChessComAnalysisUrl("b")" target="_blank" class="btn btn-primary btn-sm">
                                    ♚ Black to move
                                </a>
                            </div>
                        </div>
                        
                        <!-- Play vs Computer -->
                        <div class="mb-3">
                            <label class="form-label fw-bold">🎮 Play vs Computer on Chess.com:</label>
                            <div class="d-flex gap-2 flex-wrap align-items-center">
                                <a href="@GetChessComPlayUrl("w")" target="_blank" class="btn btn-outline-success btn-sm">
                                    ♔ Play as White
                                </a>
                                <a href="@GetChessComPlayUrl("b")" target="_blank" class="btn btn-outline-success btn-sm">
                                    ♚ Play as Black
                                </a>
                            </div>
                        </div>
                        
                        <!-- Search Games -->
                        <div class="mb-3">
                            <label class="form-label fw-bold">🔍 Find Games with this Position:</label>
                            <div class="d-flex gap-2 flex-wrap align-items-center">
                                <a href="@GetChessComSearchUrl("w")" target="_blank" class="btn btn-success btn-sm">
                                    ♔ Chess.com (White to move)
                                </a>
                                <a href="@GetChessComSearchUrl("b")" target="_blank" class="btn btn-success btn-sm">
                                    ♚ Chess.com (Black to move)
                                </a>
                                <button type="button" class="btn btn-outline-info btn-sm" @onclick="CheckChessComGames" disabled="@isCheckingGames">
                                    @if (isCheckingGames)
                                    {
                                        <span class="spinner-border spinner-border-sm me-1"></span>
                                    }
                                    🔎 Check if games exist
                                </button>
                                <button type="button" class="btn btn-outline-warning btn-sm" @onclick="CheckGridAlignment" disabled="@isCheckingAlignment">
                                    @if (isCheckingAlignment)
                                    {
                                        <span class="spinner-border spinner-border-sm me-1"></span>
                                    }
                                    📐 Check Grid Alignment
                                </button>
                            </div>
                            
                            <!-- Chess.com search results -->
                            @if (chessComSearchResults.Count > 0)
                            {
                                <div class="mt-2">
                                    @foreach (var result in chessComSearchResults)
                                    {
                                        <div class="badge @(result.GamesFound ? "bg-success" : "bg-secondary") me-2 mb-1">
                                            @(result.Side == "w" ? "♔ White" : "♚ Black"): 
                                            @(result.GamesFound ? "✓ Games found" : "✗ No games")
                                        </div>
                                    }
                                </div>
                            }
                            
                            <!-- Grid Alignment Result -->
                            @if (alignmentResult != null)
                            {
                                <div class="mt-3 p-3 border rounded @(alignmentResult.Aligned ? "border-success bg-success bg-opacity-10" : "border-warning bg-warning bg-opacity-10")">
                                    <h6 class="mb-2">📐 Grid Alignment Analysis</h6>
                                    
                                    @if (!alignmentResult.BoardDetected)
                                    {
                                        <div class="alert alert-danger py-2 mb-2">
                                            ❌ Could not detect chess board in image
                                        </div>
                                    }
                                    else
                                    {
                                        <p class="mb-2">@alignmentResult.Suggestion</p>
                                        
                                        @if (alignmentResult.PieceFound)
                                        {
                                            <div class="small text-muted mb-2">
                                                <strong>Detected piece:</strong> Square @alignmentResult.SquareName
                                                @if (alignmentResult.Offset != null && alignmentResult.Offset.Count >= 2)
                                                {
                                                    <br />
                                                    <strong>Offset from center:</strong> 
                                                    <span>@(alignmentResult.Offset[0].ToString("F0"))px horizontal, @(alignmentResult.Offset[1].ToString("F0"))px vertical</span>
                                                }
                                            </div>
                                            
                                            <div class="small">
                                                <span class="badge bg-success">🟢 Expected center (green circle)</span>
                                                <span class="badge bg-danger">🔴 Actual piece center (red dot)</span>
                                                <span class="badge bg-info">➜ Offset direction (arrow)</span>
                                            </div>
                                        }
                                    }
                                    
                                    @if (!string.IsNullOrEmpty(alignmentResult.Overlay))
                                    {
                                        <div class="mt-2 text-center">
                                            <img src="data:image/png;base64,@alignmentResult.Overlay" 
                                                 class="img-fluid border" 
                                                 style="max-width: 500px;" 
                                                 alt="Grid alignment overlay" />
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                        
                        <!-- FEN Validation -->
                        @if (fenValidation != null)
                        {
                            @if (fenValidation.IsValid && fenValidation.Warnings.Count == 0)
                            {
                                <div class="alert alert-success py-2">
                                    <span>✅ Valid chess position</span>
                                </div>
                            }
                            else if (fenValidation.IsValid && fenValidation.Warnings.Count > 0)
                            {
                                <div class="alert alert-info py-2">
                                    <span>✅ Valid position with notes:</span>
                                    <ul class="mb-0 small">
                                        @foreach (var warning in fenValidation.Warnings)
                                        {
                                            <li>⚠️ @warning</li>
                                        }
                                    </ul>
                                </div>
                            }
                            else
                            {
                                <div class="alert alert-danger py-2">
                                    <span>❌ Invalid position:</span>
                                    <ul class="mb-0 small">
                                        @foreach (var issue in fenValidation.Issues)
                                        {
                                            <li>@issue</li>
                                        }
                                    </ul>
                                    @if (fenValidation.Warnings.Count > 0)
                                    {
                                        <hr class="my-1" />
                                        <span class="small">Warnings:</span>
                                        <ul class="mb-0 small">
                                            @foreach (var warning in fenValidation.Warnings)
                                            {
                                                <li>⚠️ @warning</li>
                                            }
                                        </ul>
                                    }
                                </div>
                            }
                        }
                        
                        <!-- Chess Board Display -->
                        <div class="chess-board-container mb-3">
                            <!-- Piece Palette -->
                            <div class="piece-palette mb-2 text-center">
                                <span class="palette-label">Select piece:</span>
                                @foreach (var p in pieceOptions)
                                {
                                    var pieceKey = p.Key;
                                    <button type="button" 
                                            class="btn btn-sm piece-btn @(selectedPalettePiece == pieceKey ? "active" : "")"
                                            @onclick="() => SelectPalettePiece(pieceKey)"
                                            title="@GetPieceName(pieceKey)">
                                        @p.Value
                                    </button>
                                }
                                @if (!string.IsNullOrEmpty(selectedPalettePiece))
                                {
                                    <span class="ms-2 text-muted small">Click a square to place @GetPieceName(selectedPalettePiece)</span>
                                }
                            </div>
                            
                            <table class="chess-board mx-auto">
                                @for (int row = 0; row < 8; row++)
                                {
                                    var r = row;
                                    <tr>
                                        <td class="rank-label">@(8 - r)</td>
                                        @for (int col = 0; col < 8; col++)
                                        {
                                            var c = col;
                                            var isLight = (r + c) % 2 == 0;
                                            var square = $"{(char)('a' + c)}{8 - r}";
                                            var piece = boardPieces[r, c];
                                            
                                            <td class="@(isLight ? "light" : "dark")" 
                                                @onclick="() => OnSquareClick(square, r, c)"
                                                title="@square: @GetPieceName(piece)">
                                                <span class="piece">@GetPieceUnicode(piece)</span>
                                            </td>
                                        }
                                    </tr>
                                }
                                <tr>
                                    <td></td>
                                    @for (char c = 'a'; c <= 'h'; c++)
                                    {
                                        <td class="file-label">@c</td>
                                    }
                                </tr>
                            </table>
                            
                            <!-- Quick actions -->
                            <div class="mt-2 text-center">
                                <button class="btn btn-sm btn-outline-secondary" @onclick="ClearBoard" title="Clear all pieces">
                                    🗑️ Clear
                                </button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="ResetToOriginal" title="Reset to detected position" disabled="@(originalFen == resultFen)">
                                    ↩️ Reset
                                </button>
                            </div>
                        </div>
                        
                        <!-- Correction Actions -->
                        @if (hasCorrections)
                        {
                            <div class="alert alert-info">
                                <strong>Corrections made:</strong> @string.Join(", ", corrections.Select(c => $"{c.Key}→{c.Value}"))
                            </div>
                            <button class="btn btn-success w-100" @onclick="SubmitCorrections">
                                ✅ Submit Corrections for Training
                            </button>
                        }
                    }
                </div>
            </div>
            
            <!-- Debug Images -->
            @if (debugMode && debugImages != null)
            {
                <div class="card mt-3">
                    <div class="card-header">
                        <h5>🔧 Debug Images</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            @if (!string.IsNullOrEmpty(debugImages.Detection))
                            {
                                <div class="col-4">
                                    <label>Detection</label>
                                    <img src="data:image/png;base64,@debugImages.Detection" class="img-fluid" />
                                </div>
                            }
                            @if (!string.IsNullOrEmpty(debugImages.Warped))
                            {
                                <div class="col-4">
                                    <label>Warped</label>
                                    <img src="data:image/png;base64,@debugImages.Warped" class="img-fluid" />
                                </div>
                            }
                            @if (!string.IsNullOrEmpty(debugImages.Overlay))
                            {
                                <div class="col-4">
                                    <label>Overlay</label>
                                    <img src="data:image/png;base64,@debugImages.Overlay" class="img-fluid" />
                                </div>
                            }
                        </div>
                    </div>
                </div>
            }
        </div>
    </div>
</div>

<!-- Camera Modal (outside container for proper z-index) -->
@if (showCameraModal)
{
    <div class="camera-modal-overlay" @onclick="CloseCameraCapture">
        <div class="camera-modal" @onclick:stopPropagation="true">
            <div class="camera-header">
                <h5>📸 Capture Chess Board</h5>
                <button type="button" class="btn-close" @onclick="CloseCameraCapture"></button>
            </div>
            <div class="camera-body">
                <div id="cameraStatus" class="alert alert-info mb-2">Initializing camera...</div>
                <div class="camera-container">
                    <video id="cameraVideo" autoplay playsinline muted></video>
                    <div class="camera-guide">
                        <div class="guide-square"></div>
                        <div class="guide-text">Align board here</div>
                    </div>
                </div>
                <div class="camera-controls mt-3">
                    <button type="button" class="btn btn-success btn-lg capture-btn" id="captureBtn" @onclick="CaptureAndProcess">
                        📷 Capture
                    </button>
                    <button type="button" class="btn btn-secondary" onclick="switchCamera()">
                        🔄 Switch Camera
                    </button>
                </div>
            </div>
        </div>
    </div>
}

<style>
    .chess-board {
        border-collapse: collapse;
        border: 2px solid #333;
    }
    .chess-board td {
        width: 45px;
        height: 45px;
        text-align: center;
        vertical-align: middle;
        cursor: pointer;
        user-select: none;
    }
    .chess-board td.light { background-color: #f0d9b5; }
    .chess-board td.dark { background-color: #b58863; }
    .chess-board td:hover:not(.rank-label):not(.file-label) { 
        outline: 3px solid #007bff; 
        outline-offset: -3px;
    }
    .piece { font-size: 32px; pointer-events: none; }
    .rank-label, .file-label {
        font-weight: bold;
        background: transparent !important;
        cursor: default;
    }
    
    /* Piece palette */
    .piece-palette {
        padding: 8px;
        background: #f8f9fa;
        border-radius: 8px;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
        gap: 4px;
    }
    .palette-label {
        font-size: 14px;
        color: #666;
        margin-right: 8px;
    }
    .piece-btn {
        width: 36px;
        height: 36px;
        font-size: 24px;
        padding: 0;
        line-height: 1;
        border: 2px solid #ddd;
        background: white;
    }
    .piece-btn:hover {
        border-color: #007bff;
        background: #e7f1ff;
    }
    .piece-btn.active {
        border-color: #007bff;
        background: #cce5ff;
        box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
    }
    
    /* Camera modal styles */
    .camera-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 1050;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .camera-modal {
        background: #1a1a1a;
        border-radius: 12px;
        max-width: 95vw;
        max-height: 95vh;
        overflow: hidden;
    }
    .camera-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background: #2a2a2a;
        color: white;
    }
    .camera-header h5 {
        margin: 0;
    }
    .camera-header .btn-close {
        filter: invert(1);
    }
    .camera-body {
        padding: 16px;
        text-align: center;
    }
    .camera-container {
        position: relative;
        display: inline-block;
    }
    .camera-container video {
        max-width: 100%;
        max-height: 70vh;
        border-radius: 8px;
    }
    .camera-guide {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
    }
    .guide-square {
        width: 80%;
        aspect-ratio: 1;
        max-width: 80%;
        max-height: 80%;
        border: 3px solid #00ff00;
        border-radius: 4px;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
    }
    .guide-text {
        color: #00ff00;
        font-size: 14px;
        margin-top: 8px;
        text-shadow: 0 0 4px black;
    }
    .camera-controls {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
    }
    .capture-btn {
        opacity: 0.5;
        pointer-events: none;
    }
</style>

<script>
    // Camera capture functionality
    let cameraStream = null;
    let facingMode = 'environment'; // Start with back camera
    let cameraReady = false;
    
    function updateCameraStatus(msg, type) {
        const el = document.getElementById('cameraStatus');
        if (el) {
            el.textContent = msg;
            el.className = 'alert alert-' + (type || 'info') + ' mb-2';
        }
        console.log('[Camera]', msg);
    }
    
    function setCaptureEnabled(enabled) {
        const btn = document.getElementById('captureBtn');
        if (btn) {
            // Use class for visual state but don't set disabled attribute
            // This allows Blazor onclick to still work
            if (enabled) {
                btn.classList.remove('disabled');
                btn.style.opacity = '1';
                btn.style.pointerEvents = 'auto';
            } else {
                btn.classList.add('disabled');
                btn.style.opacity = '0.5';
                btn.style.pointerEvents = 'none';
            }
        }
    }
    
    window.startCamera = async function() {
        const video = document.getElementById('cameraVideo');
        if (!video) {
            updateCameraStatus('Video element not found', 'danger');
            return { success: false, error: 'Video element not found' };
        }
        
        cameraReady = false;
        setCaptureEnabled(false);
        updateCameraStatus('Requesting camera access...', 'info');
        
        try {
            // Stop any existing stream
            if (cameraStream) {
                cameraStream.getTracks().forEach(t => t.stop());
            }
            
            // Check if mediaDevices is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error('Camera API not supported. Make sure you are using HTTPS.');
            }
            
            // Request camera - try simple constraints first for better iOS compatibility
            let constraints = { video: true, audio: false };
            
            // Try to get back camera on mobile
            try {
                constraints = {
                    video: { facingMode: facingMode },
                    audio: false
                };
            } catch (e) {
                console.log('Using basic constraints');
            }
            
            updateCameraStatus('Opening camera...', 'info');
            cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            updateCameraStatus('Camera opened, loading video...', 'info');
            video.srcObject = cameraStream;
            
            // Wait for video to be ready (important for iOS)
            await new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => reject(new Error('Video load timeout')), 8000);
                
                video.onloadedmetadata = () => {
                    clearTimeout(timeoutId);
                    updateCameraStatus('Video metadata loaded, starting playback...', 'info');
                    video.play()
                        .then(resolve)
                        .catch(e => {
                            // iOS may block autoplay - try muted
                            video.muted = true;
                            video.play().then(resolve).catch(reject);
                        });
                };
                video.onerror = (e) => {
                    clearTimeout(timeoutId);
                    reject(e);
                };
            });
            
            // Additional wait for iOS to stabilize
            await new Promise(r => setTimeout(r, 500));
            
            cameraReady = true;
            setCaptureEnabled(true);
            updateCameraStatus('Camera ready! Align the board and tap Capture.', 'success');
            console.log('Camera ready:', video.videoWidth, 'x', video.videoHeight);
            return { success: true };
        } catch (e) {
            console.error('Camera error:', e);
            let errMsg = e.message || 'Unknown error';
            if (e.name === 'NotAllowedError') {
                errMsg = 'Camera permission denied. Please allow camera access in your browser settings.';
            } else if (e.name === 'NotFoundError') {
                errMsg = 'No camera found on this device.';
            } else if (e.name === 'NotReadableError') {
                errMsg = 'Camera is in use by another app.';
            }
            updateCameraStatus(errMsg, 'danger');
            return { success: false, error: errMsg };
        }
    };
    
    window.stopCamera = function() {
        cameraReady = false;
        if (cameraStream) {
            cameraStream.getTracks().forEach(t => t.stop());
            cameraStream = null;
        }
        const video = document.getElementById('cameraVideo');
        if (video) {
            video.srcObject = null;
        }
    };
    
    window.switchCamera = async function() {
        facingMode = facingMode === 'environment' ? 'user' : 'environment';
        updateCameraStatus('Switching camera...', 'info');
        await window.startCamera();
    };
    
    // Enhance contrast - makes whites whiter and blacks blacker
    function enhanceContrast(ctx, width, height) {
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // Step 1: Find min/max for auto-levels
        let minR = 255, maxR = 0;
        let minG = 255, maxG = 0;
        let minB = 255, maxB = 0;
        
        for (let i = 0; i < data.length; i += 4) {
            minR = Math.min(minR, data[i]);
            maxR = Math.max(maxR, data[i]);
            minG = Math.min(minG, data[i + 1]);
            maxG = Math.max(maxG, data[i + 1]);
            minB = Math.min(minB, data[i + 2]);
            maxB = Math.max(maxB, data[i + 2]);
        }
        
        // Apply auto-levels (stretch histogram)
        const rangeR = maxR - minR || 1;
        const rangeG = maxG - minG || 1;
        const rangeB = maxB - minB || 1;
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.round(((data[i] - minR) / rangeR) * 255);
            data[i + 1] = Math.round(((data[i + 1] - minG) / rangeG) * 255);
            data[i + 2] = Math.round(((data[i + 2] - minB) / rangeB) * 255);
        }
        
        // Step 2: Increase contrast (factor 1.3)
        const contrastFactor = 1.3;
        for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, Math.max(0, 128 + (data[i] - 128) * contrastFactor));
            data[i + 1] = Math.min(255, Math.max(0, 128 + (data[i + 1] - 128) * contrastFactor));
            data[i + 2] = Math.min(255, Math.max(0, 128 + (data[i + 2] - 128) * contrastFactor));
        }
        
        // Step 3: Enhance blacks (make dark areas darker)
        const blackStrength = 0.15;
        for (let i = 0; i < data.length; i += 4) {
            for (let c = 0; c < 3; c++) {
                const v = data[i + c];
                const factor = (255 - v) / 255 * (v / 255) * ((255 - v) / 255);
                data[i + c] = Math.max(0, Math.round(v - blackStrength * (255 - v) * factor));
            }
        }
        
        // Step 4: Reduce whites slightly (prevent blown highlights)
        const whiteStrength = 0.1;
        for (let i = 0; i < data.length; i += 4) {
            for (let c = 0; c < 3; c++) {
                const v = data[i + c];
                const factor = (v / 255) * (v / 255);
                data[i + c] = Math.max(0, Math.round(v - whiteStrength * v * factor));
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    
    // Apply sharpening using unsharp mask
    function sharpenImage(ctx, width, height, amount = 0.5) {
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const original = new Uint8ClampedArray(data);
        
        // Simple 3x3 sharpen kernel effect via unsharp mask
        // We approximate blur by averaging neighbors
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const idx = (y * width + x) * 4;
                
                for (let c = 0; c < 3; c++) {
                    // Get neighboring pixels for blur approximation
                    let blur = 0;
                    let count = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nidx = ((y + dy) * width + (x + dx)) * 4;
                            blur += original[nidx + c];
                            count++;
                        }
                    }
                    blur /= count;
                    
                    // Unsharp mask: original + amount * (original - blur)
                    const orig = original[idx + c];
                    const sharpened = orig + amount * (orig - blur);
                    data[idx + c] = Math.max(0, Math.min(255, Math.round(sharpened)));
                }
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    
    // Save image - uses Share API on mobile (allows Save to Photos), download on desktop
    async function saveImage(base64Data, filename) {
        const blob = await fetch('data:image/jpeg;base64,' + base64Data).then(r => r.blob());
        const file = new File([blob], filename, { type: 'image/jpeg' });
        
        // Try Web Share API first (works on iOS Safari - allows Save to Photos)
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
            try {
                await navigator.share({
                    files: [file],
                    title: 'Chess Board Capture',
                    text: 'Captured chess board image'
                });
                console.log('Image shared successfully');
                return;
            } catch (e) {
                if (e.name !== 'AbortError') {
                    console.log('Share failed, falling back to download:', e);
                }
            }
        }
        
        // Fallback: download link
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
    }
    
    window.captureFrame = async function() {
        const video = document.getElementById('cameraVideo');
        
        // Check if camera is ready
        if (!video || !cameraReady || video.readyState < 2) {
            // Try to wait a bit for camera
            if (video && video.srcObject) {
                updateCameraStatus('Waiting for camera...', 'warning');
                await new Promise(r => setTimeout(r, 500));
                if (!video.videoWidth || video.readyState < 2) {
                    updateCameraStatus('Camera not ready yet. Please wait.', 'warning');
                    return;
                }
            } else {
                updateCameraStatus('Camera not available. Close and reopen.', 'danger');
                return;
            }
        }
        
        updateCameraStatus('Capturing image...', 'info');
        
        // Calculate the square crop region (center square)
        const vw = video.videoWidth;
        const vh = video.videoHeight;
        console.log('Capturing from video:', vw, 'x', vh);
        
        const size = Math.min(vw, vh) * 0.8; // 80% of the smaller dimension
        const sx = (vw - size) / 2;
        const sy = (vh - size) / 2;
        
        // Create canvas for cropped square image
        const canvas = document.createElement('canvas');
        canvas.width = 512;  // Output size
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // Draw the cropped region
        ctx.drawImage(video, sx, sy, size, size, 0, 0, 512, 512);
        
        // No client-side preprocessing - all preprocessing is done server-side for consistency
        
        // Get base64 image
        const base64 = canvas.toDataURL('image/jpeg', 0.92).split(',')[1];
        
        // Save image to client with timestamp
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        await saveImage(base64, `chess-capture-${timestamp}.jpg`);
        
        // Stop camera
        window.stopCamera();
        
        // Store in window for Blazor to retrieve
        window.capturedImageBase64 = base64;
        
        // Call Blazor to handle the captured image
        try {
            await DotNet.invokeMethodAsync('ChessFEN.Web', 'HandleCameraCapture', base64);
        } catch (e) {
            console.error('Error calling HandleCameraCapture:', e);
        }
    };
    
    // Capture frame and return base64 directly (called from Blazor)
    window.captureFrameAndReturn = async function() {
        const video = document.getElementById('cameraVideo');
        
        // Check if camera is ready
        if (!video || !cameraReady || video.readyState < 2) {
            if (video && video.srcObject) {
                await new Promise(r => setTimeout(r, 500));
                if (!video.videoWidth || video.readyState < 2) {
                    console.error('Camera not ready');
                    return null;
                }
            } else {
                console.error('Camera not available');
                return null;
            }
        }
        
        updateCameraStatus('Capturing image...', 'info');
        
        // Calculate the square crop region (center square)
        const vw = video.videoWidth;
        const vh = video.videoHeight;
        console.log('Capturing from video:', vw, 'x', vh);
        
        const size = Math.min(vw, vh) * 0.8;
        const sx = (vw - size) / 2;
        const sy = (vh - size) / 2;
        
        // Create canvas for cropped square image
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // Draw the cropped region
        ctx.drawImage(video, sx, sy, size, size, 0, 0, 512, 512);
        
        // No client-side preprocessing - all preprocessing is done server-side for consistency
        
        // Get base64 image
        const base64 = canvas.toDataURL('image/jpeg', 0.92).split(',')[1];
        
        // Stop camera first
        window.stopCamera();
        
        // Save image to client (don't await - let it happen in background)
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        saveImage(base64, `chess-capture-${timestamp}.jpg`);
        
        return base64;
    };
    
    // Function to get captured image (called from Blazor)
    window.getCapturedImage = function() {
        const img = window.capturedImageBase64;
        window.capturedImageBase64 = null;
        return img;
    };
    
    // Direct copy function for iOS - must be called from onclick directly (not Blazor)
    function copyFenFromInput(inputId, button) {
        const input = document.getElementById(inputId);
        if (!input) return;
        
        const text = input.value;
        const originalText = button.innerHTML;
        
        // iOS Safari: select and copy from input
        input.focus();
        input.setSelectionRange(0, text.length);
        
        let copied = false;
        
        // Try execCommand first (works in user gesture context)
        try {
            copied = document.execCommand('copy');
        } catch (e) {
            copied = false;
        }
        
        // Try modern clipboard API
        if (!copied && navigator.clipboard) {
            navigator.clipboard.writeText(text).then(function() {
                button.innerHTML = '✓ Copied!';
                setTimeout(function() { button.innerHTML = originalText; }, 2000);
            }).catch(function() {
                button.innerHTML = '⚠ Select & Copy';
                setTimeout(function() { button.innerHTML = originalText; }, 2000);
            });
            return;
        }
        
        if (copied) {
            button.innerHTML = '✓ Copied!';
        } else {
            button.innerHTML = '⚠ Select & Copy';
        }
        
        setTimeout(function() { button.innerHTML = originalText; }, 2000);
    }

    window.copyToClipboardFallback = async function(text) {
        // Try modern clipboard API first
        if (navigator.clipboard && window.isSecureContext) {
            try {
                await navigator.clipboard.writeText(text);
                return { success: true };
            } catch (e) {
                // Fall through to fallback
            }
        }
        
        // Fallback: Create temporary textarea
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            const successful = document.execCommand('copy');
            textArea.remove();
            if (successful) {
                return { success: true };
            }
        } catch (e) {
            textArea.remove();
        }
        
        // Last resort: prompt user
        return { success: false, text: text };
    };
</script>

@code {
    private string? imageBase64;
    private string? imagePreview;
    private string? resultFen;
    private string? originalFen;
    private string? errorMessage;
    private bool isLoading = false;
    private bool debugMode = false;
    private bool skipDetection = false;
    private string selectedModel = "";
    
    private string[,] boardPieces = new string[8, 8];
    private string? editingSquare;
    private Dictionary<string, string> corrections = new();
    private bool hasCorrections => corrections.Count > 0;
    private FenValidationResult? fenValidation;
    
    private DebugImagesModel? debugImages;
    private List<ModelInfo> availableModels = new();
    private List<string> debugLogs = new();
    
    private bool buttonDisabled => isLoading || !hasImage;
    
    private int testCounter = 0;
    
    // Camera capture
    private bool showCameraModal = false;
    private static Home? _instance;
    
    // Chess.com game search
    private bool isCheckingGames = false;
    private List<ChessComSearchResultItem> chessComSearchResults = new();
    
    // Grid alignment check
    private bool isCheckingAlignment = false;
    private GridAlignmentResult? alignmentResult;
    
    private Dictionary<string, string> pieceOptions = new()
    {
        { "empty", "·" },
        { "wK", "♔" }, { "wQ", "♕" }, { "wR", "♖" }, { "wB", "♗" }, { "wN", "♘" }, { "wP", "♙" },
        { "bK", "♚" }, { "bQ", "♛" }, { "bR", "♜" }, { "bB", "♝" }, { "bN", "♞" }, { "bP", "♟" }
    };
    
    private string? selectedPalettePiece = "empty";
    
    private void Log(string message)
    {
        var timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
        var logMessage = $"[{timestamp}] {message}";
        debugLogs.Add(logMessage);
        Logger.LogInformation(logMessage);
        Console.WriteLine(logMessage);
    }
    
    // Camera capture methods
    private async Task OpenCameraCapture()
    {
        Log("Opening camera capture...");
        _instance = this;
        showCameraModal = true;
        StateHasChanged();
        
        // Give the modal time to render, then start camera
        await Task.Delay(100);
        try
        {
            await JSRuntime.InvokeVoidAsync("startCamera");
        }
        catch (Exception ex)
        {
            Log($"Camera error: {ex.Message}");
            errorMessage = "Could not access camera. Please check permissions.";
            showCameraModal = false;
            StateHasChanged();
        }
    }
    
    private async Task CloseCameraCapture()
    {
        Log("Closing camera capture...");
        try
        {
            await JSRuntime.InvokeVoidAsync("stopCamera");
        }
        catch { }
        
        // Check if there's a captured image waiting
        try
        {
            var capturedBase64 = await JSRuntime.InvokeAsync<string>("getCapturedImage");
            if (!string.IsNullOrEmpty(capturedBase64))
            {
                Log($"Retrieved captured image via getCapturedImage, length: {capturedBase64.Length}");
                await ProcessCameraCapture(capturedBase64);
                return;
            }
        }
        catch (Exception ex)
        {
            Log($"Error getting captured image: {ex.Message}");
        }
        
        showCameraModal = false;
        StateHasChanged();
    }
    
    private async Task CaptureAndProcess()
    {
        Log("CaptureAndProcess called from Blazor button");
        try
        {
            // Call JS to capture and get the base64 directly
            var base64 = await JSRuntime.InvokeAsync<string>("captureFrameAndReturn");
            if (!string.IsNullOrEmpty(base64))
            {
                Log($"Got captured image, length: {base64.Length}");
                await ProcessCameraCapture(base64);
            }
            else
            {
                Log("captureFrameAndReturn returned empty");
            }
        }
        catch (Exception ex)
        {
            Log($"Error in CaptureAndProcess: {ex.Message}");
        }
    }
    
    [JSInvokable]
    public static async Task HandleCameraCapture(string base64Image)
    {
        if (_instance == null) return;
        await _instance.ProcessCameraCapture(base64Image);
    }
    
    private async Task ProcessCameraCapture(string base64Image)
    {
        Log($"Received camera capture, base64 length: {base64Image.Length}");
        
        showCameraModal = false;
        
        // Clean the base64 string (remove any whitespace/newlines)
        imageBase64 = base64Image.Replace("\n", "").Replace("\r", "").Replace(" ", "");
        imagePreview = $"data:image/jpeg;base64,{imageBase64}";
        hasImage = true;
        selectedFile = null; // Clear file reference since we have base64 directly
        
        Log($"Preview set, length: {imagePreview.Length}, starts with: {imagePreview.Substring(0, Math.Min(50, imagePreview.Length))}");
        
        // Clear previous results
        resultFen = null;
        errorMessage = null;
        fenValidation = null;
        corrections.Clear();
        chessComSearchResults.Clear();
        alignmentResult = null;
        InitializeBoard();
        
        await InvokeAsync(StateHasChanged);
    }
    
    private async Task OnAnalyzeClick()
    {
        Log(">>> OnAnalyzeClick triggered! <<<");
        await PredictFen();
    }
    
    private void TestClick()
    {
        testCounter++;
        Log($">>> TestClick! Counter: {testCounter} <<<");
    }

    protected override async Task OnInitializedAsync()
    {
        Log("OnInitializedAsync called");
        Log($"HttpClient BaseAddress: {Http.BaseAddress}");
        InitializeBoard();
    }

    private void InitializeBoard()
    {
        for (int r = 0; r < 8; r++)
            for (int c = 0; c < 8; c++)
                boardPieces[r, c] = "empty";
    }

    private async Task LoadModels()
    {
        if (!debugMode) return;
        
        Log("LoadModels called");
        try
        {
            var url = "/api/chess/models";
            Log($"GET {url}");
            var response = await Http.GetAsync(url);
            Log($"Response: {response.StatusCode}");
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                Log($"Models JSON: {json.Substring(0, Math.Min(200, json.Length))}...");
                availableModels = JsonSerializer.Deserialize<List<ModelInfo>>(json, 
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new();
                
                var best = availableModels.FirstOrDefault(m => m.IsBest);
                if (best != null) selectedModel = best.Name;
                Log($"Loaded {availableModels.Count} models, selected: {selectedModel}");
            }
            else
            {
                Log($"Failed to load models: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Log($"LoadModels error: {ex.Message}");
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        Log("HandleFileSelected called");
        var file = e.File;
        if (file == null)
        {
            Log("No file selected");
            return;
        }

        Log($"File: {file.Name}, Size: {file.Size} bytes, Type: {file.ContentType}");
        
        // Store file reference for later, don't read into memory yet
        selectedFile = file;
        imagePreview = "pending"; // Signal that we have a file but haven't loaded preview
        hasImage = true;
        Log($"File selected, ready for analysis. hasImage={hasImage}");
        
        // Clear previous results
        resultFen = null;
        errorMessage = null;
        fenValidation = null;
        corrections.Clear();
        chessComSearchResults.Clear();
        alignmentResult = null;
        InitializeBoard();
        
        // Force UI update (needed for iOS)
        await InvokeAsync(StateHasChanged);
    }
    
    private IBrowserFile? selectedFile;
    private bool hasImage = false;

    private async Task PredictFen()
    {
        Log("=== PredictFen STARTED ===");
        
        // Check if we have an image (either from file or camera capture)
        if (selectedFile == null && string.IsNullOrEmpty(imageBase64))
        {
            Log("ERROR: No image available");
            return;
        }
        
        isLoading = true;
        errorMessage = null;
        StateHasChanged();
        
        try
        {
            string base64Data;
            
            if (selectedFile != null)
            {
                // Read file now (only when needed for API call)
                Log($"Reading file: {selectedFile.Name}, Size: {selectedFile.Size}");
                
                // Read all bytes properly using MemoryStream
                using var memoryStream = new MemoryStream();
                await selectedFile.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024).CopyToAsync(memoryStream);
                var buffer = memoryStream.ToArray();
                Log($"Bytes read: {buffer.Length}");
                
                base64Data = Convert.ToBase64String(buffer);
                Log($"File read, base64 length: {base64Data.Length}");
                
                // Store for preview after success
                imageBase64 = base64Data;
                imagePreview = $"data:{selectedFile.ContentType};base64,{base64Data}";
            }
            else
            {
                // Use camera-captured base64 directly
                base64Data = imageBase64!;
                Log($"Using camera capture, base64 length: {base64Data.Length}");
            }
            
            // Build query parameters
            var queryParams = new List<string>();
            if (debugMode)
            {
                queryParams.Add("debug=true");
                queryParams.Add($"model={selectedModel}");
            }
            if (skipDetection) queryParams.Add("skipDetection=true");
            var query = queryParams.Count > 0 ? "?" + string.Join("&", queryParams) : "";
            
            var url = $"/api/chess/predict/base64{query}";
            Log($"POST {url} (skipDetection={skipDetection})");
            Log($"HttpClient.BaseAddress = {Http.BaseAddress}");
            
            var payload = JsonSerializer.Serialize(new { image = base64Data });
            Log($"Payload size: {payload.Length} chars");
            
            var content = new StringContent(payload, System.Text.Encoding.UTF8, "application/json");
            
            Log("Sending HTTP request...");
            var response = await Http.PostAsync(url, content);
            Log($"Response received: {response.StatusCode}");
            
            var json = await response.Content.ReadAsStringAsync();
            Log($"Response body length: {json.Length}");
            Log($"Response body (first 500 chars): {json.Substring(0, Math.Min(500, json.Length))}");
            
            var result = JsonSerializer.Deserialize<PredictionResult>(json, 
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
            
            if (result?.Success == true)
            {
                Log($"SUCCESS! FEN: {result.Fen}");
                resultFen = result.Fen;
                originalFen = result.Fen;
                fenValidation = ValidateFen(resultFen ?? "");
                Log($"Validation: {(fenValidation.IsValid ? "Valid" : "Invalid")} - {fenValidation.Issues.Count} issues");
                ParseBoardFromResult(result.Board);
                debugImages = result.DebugImages;
            }
            else
            {
                Log($"FAILED: {result?.Error ?? "Unknown error"}");
                errorMessage = result?.Error ?? "Unknown error";
            }
        }
        catch (Exception ex)
        {
            Log($"EXCEPTION: {ex.GetType().Name}: {ex.Message}");
            Log($"Stack: {ex.StackTrace?.Substring(0, Math.Min(300, ex.StackTrace?.Length ?? 0))}");
            errorMessage = $"Error: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            Log("=== PredictFen COMPLETED ===");
            StateHasChanged();
        }
    }

    private void ParseBoardFromResult(string[][]? board)
    {
        if (board == null) return;
        
        for (int r = 0; r < 8 && r < board.Length; r++)
        {
            for (int c = 0; c < 8 && c < board[r].Length; c++)
            {
                boardPieces[r, c] = board[r][c] ?? "empty";
            }
        }
    }

    private string GetPieceUnicode(string piece)
    {
        if (piece == "empty") return "";
        return pieceOptions.TryGetValue(piece, out var unicode) ? unicode : "";
    }
    
    private string GetPieceName(string piece) => piece switch
    {
        "empty" => "Empty",
        "wK" => "White King", "wQ" => "White Queen", "wR" => "White Rook",
        "wB" => "White Bishop", "wN" => "White Knight", "wP" => "White Pawn",
        "bK" => "Black King", "bQ" => "Black Queen", "bR" => "Black Rook",
        "bB" => "Black Bishop", "bN" => "Black Knight", "bP" => "Black Pawn",
        _ => piece
    };
    
    private void SelectPalettePiece(string piece)
    {
        selectedPalettePiece = piece;
    }
    
    private void OnSquareClick(string square, int row, int col)
    {
        if (string.IsNullOrEmpty(selectedPalettePiece)) return;
        
        var oldPiece = boardPieces[row, col];
        if (oldPiece != selectedPalettePiece)
        {
            boardPieces[row, col] = selectedPalettePiece;
            corrections[square] = selectedPalettePiece;
            resultFen = GenerateFenFromBoard();
            fenValidation = ValidateFen(resultFen ?? "");
            chessComSearchResults.Clear(); // Clear old search results
            StateHasChanged();
        }
    }
    
    private void ClearBoard()
    {
        for (int r = 0; r < 8; r++)
            for (int c = 0; c < 8; c++)
                boardPieces[r, c] = "empty";
        
        resultFen = GenerateFenFromBoard();
        fenValidation = ValidateFen(resultFen ?? "");
        corrections.Clear();
        corrections["cleared"] = "all";
        chessComSearchResults.Clear(); // Clear old search results
        StateHasChanged();
    }
    
    private void ResetToOriginal()
    {
        if (string.IsNullOrEmpty(originalFen)) return;
        
        resultFen = originalFen;
        ParseFenToBoard(originalFen);
        fenValidation = ValidateFen(resultFen ?? "");
        corrections.Clear();
        chessComSearchResults.Clear(); // Clear old search results
        StateHasChanged();
    }
    
    private void ParseFenToBoard(string fen)
    {
        var piecePlacement = fen.Split(' ')[0];
        var ranks = piecePlacement.Split('/');
        
        for (int r = 0; r < 8 && r < ranks.Length; r++)
        {
            int col = 0;
            foreach (char c in ranks[r])
            {
                if (char.IsDigit(c))
                {
                    for (int i = 0; i < (c - '0') && col < 8; i++)
                        boardPieces[r, col++] = "empty";
                }
                else
                {
                    boardPieces[r, col++] = FenCharToPiece(c);
                }
            }
        }
    }
    
    private string FenCharToPiece(char c) => c switch
    {
        'K' => "wK", 'Q' => "wQ", 'R' => "wR", 'B' => "wB", 'N' => "wN", 'P' => "wP",
        'k' => "bK", 'q' => "bQ", 'r' => "bR", 'b' => "bB", 'n' => "bN", 'p' => "bP",
        _ => "empty"
    };

    private void StartEditing(string square, int row, int col)
    {
        editingSquare = editingSquare == square ? null : square;
    }

    private void UpdatePiece(string square, int row, int col, string? newPiece)
    {
        if (string.IsNullOrEmpty(newPiece)) return;
        
        var oldPiece = boardPieces[row, col];
        if (oldPiece != newPiece)
        {
            boardPieces[row, col] = newPiece;
            corrections[square] = newPiece;
            resultFen = GenerateFenFromBoard();
            fenValidation = ValidateFen(resultFen ?? "");
        }
        editingSquare = null;
    }

    private string GenerateFenFromBoard()
    {
        var rows = new List<string>();
        for (int r = 0; r < 8; r++)
        {
            var row = "";
            int empty = 0;
            for (int c = 0; c < 8; c++)
            {
                var piece = boardPieces[r, c];
                if (piece == "empty")
                {
                    empty++;
                }
                else
                {
                    if (empty > 0) { row += empty; empty = 0; }
                    row += PieceToFenChar(piece);
                }
            }
            if (empty > 0) row += empty;
            rows.Add(row);
        }
        return string.Join("/", rows);
    }

    private string PieceToFenChar(string piece) => piece switch
    {
        "wP" => "P", "wN" => "N", "wB" => "B", "wR" => "R", "wQ" => "Q", "wK" => "K",
        "bP" => "p", "bN" => "n", "bB" => "b", "bR" => "r", "bQ" => "q", "bK" => "k",
        _ => ""
    };

    private async Task SubmitCorrections()
    {
        try
        {
            var payload = JsonSerializer.Serialize(new
            {
                originalFen = originalFen,
                correctedFen = resultFen,
                image = imageBase64,
                correctedSquares = corrections
            });
            var content = new StringContent(payload, System.Text.Encoding.UTF8, "application/json");
            
            var response = await Http.PostAsync("/api/chess/feedback", content);
            
            if (response.IsSuccessStatusCode)
            {
                corrections.Clear();
                StateHasChanged();
            }
        }
        catch { /* ignore */ }
    }

    private async Task CopyFen()
    {
        await CopyToClipboard(resultFen ?? "");
    }

    private async Task CopyWhiteFen()
    {
        await CopyToClipboard(GetFullFen("w"));
    }

    private async Task CopyBlackFen()
    {
        await CopyToClipboard(GetFullFen("b"));
    }

    private string GetFullFen(string sideToMove)
    {
        if (string.IsNullOrEmpty(resultFen)) return "";
        
        // Build full FEN: pieces side castling enpassant halfmove fullmove
        // We can try to infer castling rights from piece positions
        var castling = InferCastlingRights();
        
        // Format: [pieces] [side] [castling] [enpassant] [halfmove] [fullmove]
        return $"{resultFen} {sideToMove} {castling} - 0 1";
    }
    
    private string GetChessComSearchUrl(string sideToMove)
    {
        var fullFen = GetFullFen(sideToMove);
        if (string.IsNullOrEmpty(fullFen)) return "#";
        
        var encodedFen = Uri.EscapeDataString(fullFen);
        return $"https://www.chess.com/games/search?fen={encodedFen}";
    }
    
    private string GetChessComAnalysisUrl(string sideToMove)
    {
        var fullFen = GetFullFen(sideToMove);
        if (string.IsNullOrEmpty(fullFen)) return "#";
        
        var encodedFen = Uri.EscapeDataString(fullFen);
        var flip = sideToMove == "b" ? "true" : "false";
        return $"https://www.chess.com/analysis?fen={encodedFen}&flip={flip}&tab=analysis";
    }
    
    private string GetChessComPlayUrl(string sideToMove)
    {
        var fullFen = GetFullFen(sideToMove);
        if (string.IsNullOrEmpty(fullFen)) return "#";
        
        var encodedFen = Uri.EscapeDataString(fullFen);
        var flip = sideToMove == "b" ? "true" : "false";
        return $"https://www.chess.com/analysis?fen={encodedFen}&flip={flip}&tab=play";
    }
    
    private string GetLichessSearchUrl(string sideToMove)
    {
        var fullFen = GetFullFen(sideToMove);
        if (string.IsNullOrEmpty(fullFen)) return "#";
        
        // Lichess uses analysis board with FEN parameter
        var encodedFen = Uri.EscapeDataString(fullFen);
        return $"https://lichess.org/analysis?fen={encodedFen}";
    }
    
    private async Task CheckChessComGames()
    {
        if (string.IsNullOrEmpty(resultFen)) return;
        
        isCheckingGames = true;
        chessComSearchResults.Clear();
        StateHasChanged();
        
        try
        {
            // Check both white and black to move
            foreach (var side in new[] { "w", "b" })
            {
                var fullFen = GetFullFen(side);
                var encodedFen = Uri.EscapeDataString(fullFen);
                
                var response = await Http.GetAsync($"/api/chess/chess-com-search?fen={encodedFen}");
                if (response.IsSuccessStatusCode)
                {
                    var json = await response.Content.ReadAsStringAsync();
                    var result = JsonSerializer.Deserialize<ChessComSearchResponse>(json, 
                        new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    
                    chessComSearchResults.Add(new ChessComSearchResultItem
                    {
                        Side = side,
                        GamesFound = result?.GamesFound ?? false,
                        Message = result?.Message
                    });
                }
                else
                {
                    chessComSearchResults.Add(new ChessComSearchResultItem
                    {
                        Side = side,
                        GamesFound = false,
                        Message = "Error checking"
                    });
                }
            }
        }
        catch (Exception ex)
        {
            Log($"Error checking Chess.com: {ex.Message}");
        }
        finally
        {
            isCheckingGames = false;
            StateHasChanged();
        }
    }

    private async Task CheckGridAlignment()
    {
        if (string.IsNullOrEmpty(imageBase64)) return;
        
        isCheckingAlignment = true;
        alignmentResult = null;
        StateHasChanged();
        
        try
        {
            var payload = new { image = imageBase64, skip_detection = skipDetection };
            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, System.Text.Encoding.UTF8, "application/json");
            
            var response = await Http.PostAsync("/api/chess/align", content);
            if (response.IsSuccessStatusCode)
            {
                var responseJson = await response.Content.ReadAsStringAsync();
                alignmentResult = JsonSerializer.Deserialize<GridAlignmentResult>(responseJson, 
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
            }
            else
            {
                alignmentResult = new GridAlignmentResult
                {
                    Success = false,
                    Suggestion = "Failed to analyze image"
                };
            }
        }
        catch (Exception ex)
        {
            Log($"Error checking alignment: {ex.Message}");
            alignmentResult = new GridAlignmentResult
            {
                Success = false,
                Suggestion = $"Error: {ex.Message}"
            };
        }
        finally
        {
            isCheckingAlignment = false;
            StateHasChanged();
        }
    }

    private string InferCastlingRights()
    {
        // Check if kings and rooks are on starting squares
        var rights = "";
        
        // White: King on e1 (row 7, col 4)
        if (boardPieces[7, 4] == "wK")
        {
            // White kingside: Rook on h1 (row 7, col 7)
            if (boardPieces[7, 7] == "wR") rights += "K";
            // White queenside: Rook on a1 (row 7, col 0)
            if (boardPieces[7, 0] == "wR") rights += "Q";
        }
        
        // Black: King on e8 (row 0, col 4)
        if (boardPieces[0, 4] == "bK")
        {
            // Black kingside: Rook on h8 (row 0, col 7)
            if (boardPieces[0, 7] == "bR") rights += "k";
            // Black queenside: Rook on a8 (row 0, col 0)
            if (boardPieces[0, 0] == "bR") rights += "q";
        }
        
        return string.IsNullOrEmpty(rights) ? "-" : rights;
    }

    private string? clipboardMessage;
    
    private async Task CopyToClipboard(string text)
    {
        try
        {
            var result = await JSRuntime.InvokeAsync<ClipboardResult>("copyToClipboardFallback", text);
            if (result.Success)
            {
                clipboardMessage = "✓ Copied!";
            }
            else
            {
                // Show the text in an alert for manual copying on iOS
                clipboardMessage = "Select & copy: " + text;
            }
            StateHasChanged();
            await Task.Delay(3000);
            clipboardMessage = null;
            StateHasChanged();
        }
        catch
        {
            clipboardMessage = "Long-press to copy: " + text;
            StateHasChanged();
        }
    }

    private class ClipboardResult
    {
        public bool Success { get; set; }
        public string? Text { get; set; }
    }

    // Model classes
    public class PredictionResult
    {
        public bool Success { get; set; }
        public string? Fen { get; set; }
        public string[][]? Board { get; set; }
        public string? Error { get; set; }
        public DebugImagesModel? DebugImages { get; set; }
    }

    public class DebugImagesModel
    {
        public string? Detection { get; set; }
        public string? Warped { get; set; }
        public string? Overlay { get; set; }
    }

    public class ModelInfo
    {
        public string Name { get; set; } = "";
        public string Type { get; set; } = "";
        public string? Accuracy { get; set; }
        public bool IsBest { get; set; }
    }

    // FEN Validation
    public class FenValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Issues { get; set; } = new();
        public List<string> Warnings { get; set; } = new();
    }

    private FenValidationResult ValidateFen(string fen)
    {
        var result = new FenValidationResult { IsValid = true };
        
        if (string.IsNullOrWhiteSpace(fen))
        {
            result.IsValid = false;
            result.Issues.Add("FEN string is empty");
            return result;
        }

        // Take only the piece placement part (before any space)
        var piecePlacement = fen.Split(' ')[0];
        var ranks = piecePlacement.Split('/');

        // Must have 8 ranks
        if (ranks.Length != 8)
        {
            result.IsValid = false;
            result.Issues.Add($"Expected 8 ranks, found {ranks.Length}");
            return result;
        }

        // Count all pieces
        int whiteKings = 0, blackKings = 0;
        int whiteQueens = 0, blackQueens = 0;
        int whiteRooks = 0, blackRooks = 0;
        int whiteBishops = 0, blackBishops = 0;
        int whiteKnights = 0, blackKnights = 0;
        int whitePawns = 0, blackPawns = 0;
        var validPieces = "KQRBNPkqrbnp";
        
        // Track bishop square colors
        bool whiteBishopOnLight = false, whiteBishopOnDark = false;
        bool blackBishopOnLight = false, blackBishopOnDark = false;

        for (int rankIdx = 0; rankIdx < 8; rankIdx++)
        {
            var rank = ranks[rankIdx];
            int col = 0;

            foreach (char c in rank)
            {
                if (char.IsDigit(c))
                {
                    int emptyCount = c - '0';
                    if (emptyCount < 1 || emptyCount > 8)
                    {
                        result.IsValid = false;
                        result.Issues.Add($"Invalid empty square count '{c}' in rank {8-rankIdx}");
                    }
                    col += emptyCount;
                }
                else if (validPieces.Contains(c))
                {
                    bool isLightSquare = (rankIdx + col) % 2 == 0;
                    
                    // Count pieces and track bishops
                    switch (c)
                    {
                        case 'K': whiteKings++; break;
                        case 'k': blackKings++; break;
                        case 'Q': whiteQueens++; break;
                        case 'q': blackQueens++; break;
                        case 'R': whiteRooks++; break;
                        case 'r': blackRooks++; break;
                        case 'B': 
                            whiteBishops++; 
                            if (isLightSquare) whiteBishopOnLight = true; else whiteBishopOnDark = true;
                            break;
                        case 'b': 
                            blackBishops++; 
                            if (isLightSquare) blackBishopOnLight = true; else blackBishopOnDark = true;
                            break;
                        case 'N': whiteKnights++; break;
                        case 'n': blackKnights++; break;
                        case 'P': whitePawns++; break;
                        case 'p': blackPawns++; break;
                    }
                    
                    // Check for pawns on 1st or 8th rank (illegal)
                    if ((c == 'P' || c == 'p') && (rankIdx == 0 || rankIdx == 7))
                    {
                        result.IsValid = false;
                        result.Issues.Add($"Pawn on rank {8-rankIdx} is illegal");
                    }
                    
                    col++;
                }
                else
                {
                    result.IsValid = false;
                    result.Issues.Add($"Invalid character '{c}' in rank {8-rankIdx}");
                }
            }

            if (col != 8)
            {
                result.IsValid = false;
                result.Issues.Add($"Rank {8-rankIdx} has {col} squares (expected 8)");
            }
        }

        // === CRITICAL VALIDATIONS (make position invalid) ===
        
        // King validation - exactly one of each required
        if (whiteKings == 0)
        {
            result.IsValid = false;
            result.Issues.Add("Missing white king ♔");
        }
        else if (whiteKings > 1)
        {
            result.IsValid = false;
            result.Issues.Add($"Too many white kings: {whiteKings} (max 1)");
        }

        if (blackKings == 0)
        {
            result.IsValid = false;
            result.Issues.Add("Missing black king ♚");
        }
        else if (blackKings > 1)
        {
            result.IsValid = false;
            result.Issues.Add($"Too many black kings: {blackKings} (max 1)");
        }
        
        // Pawn count - max 8 each
        if (whitePawns > 8)
        {
            result.IsValid = false;
            result.Issues.Add($"Too many white pawns: {whitePawns} (max 8)");
        }
        if (blackPawns > 8)
        {
            result.IsValid = false;
            result.Issues.Add($"Too many black pawns: {blackPawns} (max 8)");
        }

        // === WARNINGS (unusual but technically possible with promotions) ===
        
        // Calculate max possible promoted pieces (8 pawns - current pawns = max promotions)
        int whitePossiblePromotions = 8 - whitePawns;
        int blackPossiblePromotions = 8 - blackPawns;
        
        // Extra pieces beyond starting count
        int whiteExtraQueens = Math.Max(0, whiteQueens - 1);
        int whiteExtraRooks = Math.Max(0, whiteRooks - 2);
        int whiteExtraBishops = Math.Max(0, whiteBishops - 2);
        int whiteExtraKnights = Math.Max(0, whiteKnights - 2);
        int whiteTotalExtra = whiteExtraQueens + whiteExtraRooks + whiteExtraBishops + whiteExtraKnights;
        
        int blackExtraQueens = Math.Max(0, blackQueens - 1);
        int blackExtraRooks = Math.Max(0, blackRooks - 2);
        int blackExtraBishops = Math.Max(0, blackBishops - 2);
        int blackExtraKnights = Math.Max(0, blackKnights - 2);
        int blackTotalExtra = blackExtraQueens + blackExtraRooks + blackExtraBishops + blackExtraKnights;
        
        // Check if promotions exceed what's possible
        if (whiteTotalExtra > whitePossiblePromotions)
        {
            result.Warnings.Add($"White has {whiteTotalExtra} extra pieces but only {whitePossiblePromotions} possible promotions");
        }
        if (blackTotalExtra > blackPossiblePromotions)
        {
            result.Warnings.Add($"Black has {blackTotalExtra} extra pieces but only {blackPossiblePromotions} possible promotions");
        }
        
        // Two bishops on same color is unusual (possible via promotion, but rare)
        if (whiteBishops >= 2 && whiteBishopOnLight && !whiteBishopOnDark)
        {
            result.Warnings.Add("White has 2+ bishops, all on light squares");
        }
        if (whiteBishops >= 2 && whiteBishopOnDark && !whiteBishopOnLight)
        {
            result.Warnings.Add("White has 2+ bishops, all on dark squares");
        }
        if (blackBishops >= 2 && blackBishopOnLight && !blackBishopOnDark)
        {
            result.Warnings.Add("Black has 2+ bishops, all on light squares");
        }
        if (blackBishops >= 2 && blackBishopOnDark && !blackBishopOnLight)
        {
            result.Warnings.Add("Black has 2+ bishops, all on dark squares");
        }
        
        // Total piece count check (max 16 per side)
        int whiteTotalPieces = whiteKings + whiteQueens + whiteRooks + whiteBishops + whiteKnights + whitePawns;
        int blackTotalPieces = blackKings + blackQueens + blackRooks + blackBishops + blackKnights + blackPawns;
        
        if (whiteTotalPieces > 16)
        {
            result.IsValid = false;
            result.Issues.Add($"White has {whiteTotalPieces} pieces (max 16)");
        }
        if (blackTotalPieces > 16)
        {
            result.IsValid = false;
            result.Issues.Add($"Black has {blackTotalPieces} pieces (max 16)");
        }

        return result;
    }
    
    // Chess.com search models
    public class ChessComSearchResponse
    {
        public bool Success { get; set; }
        public bool GamesFound { get; set; }
        public string? SearchUrl { get; set; }
        public string? Message { get; set; }
        public string? Error { get; set; }
    }
    
    public class ChessComSearchResultItem
    {
        public string Side { get; set; } = "";
        public bool GamesFound { get; set; }
        public string? Message { get; set; }
    }
    
    // Grid alignment models
    public class GridAlignmentResult
    {
        public bool Success { get; set; }
        public bool BoardDetected { get; set; }
        public bool PieceFound { get; set; }
        public List<double>? PieceCenter { get; set; }
        public List<int>? PieceSquare { get; set; }
        public string? SquareName { get; set; }
        public List<double>? Offset { get; set; }
        public double Confidence { get; set; }
        public bool Aligned { get; set; }
        public string? Suggestion { get; set; }
        public string? Overlay { get; set; }
        public string? Error { get; set; }
    }
}

