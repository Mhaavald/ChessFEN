@page "/"
@using System.Text.Json
@inject HttpClient Http
@inject IConfiguration Configuration
@inject ILogger<Home> Logger
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

<PageTitle>Chess FEN Scanner</PageTitle>

<div class="container">
    <h1 class="text-center mb-4">♔ Chess FEN Scanner</h1>
    
    <div class="row">
        <!-- Left: Image Upload/Capture -->
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h5>📷 Capture or Upload Image</h5>
                </div>
                <div class="card-body">
                    <!-- File Upload -->
                    <div class="mb-3">
                        <label class="form-label">Upload chess board image:</label>
                        <InputFile OnChange="HandleFileSelected" class="form-control" accept="image/*" />
                    </div>
                    
                    <!-- Camera Capture (mobile) -->
                    <div class="mb-3">
                        <label class="form-label">Or capture from camera:</label>
                        <InputFile OnChange="HandleFileSelected" class="form-control" accept="image/*" capture="environment" />
                    </div>
                    
                    <!-- Preview -->
                    @if (hasImage)
                    {
                        <div class="text-center mb-3">
                            @if (!string.IsNullOrEmpty(imagePreview) && imagePreview != "pending")
                            {
                                <img src="@imagePreview" alt="Preview" class="img-fluid" style="max-height: 300px;" />
                            }
                            else
                            {
                                <div class="alert alert-info">
                                    📁 File selected: @(selectedFile?.Name ?? "Unknown") (@(selectedFile?.Size / 1024) KB)
                                    <br/><small>Click "Analyze Board" to process</small>
                                </div>
                            }
                        </div>
                    }
                    
                    <!-- Model Selection (Debug) -->
                    @if (debugMode)
                    {
                        <div class="mb-3">
                            <label class="form-label">Model:</label>
                            <select class="form-select" @bind="selectedModel">
                                @foreach (var model in availableModels)
                                {
                                    <option value="@model.Name">@model.Name (@model.Type) - @model.Accuracy</option>
                                }
                            </select>
                        </div>
                    }
                    
                    <!-- Predict Button -->
                    <button type="button" class="btn btn-primary btn-lg w-100" @onclick="OnAnalyzeClick" disabled="@buttonDisabled">
                        @if (isLoading)
                        {
                            <span class="spinner-border spinner-border-sm me-2"></span>
                        }
                        🔍 Analyze Board
                    </button>
                    
                    <!-- Test Button -->
                    <button type="button" class="btn btn-warning mt-2 w-100" @onclick="TestClick">
                        🧪 Test Click (Counter: @testCounter)
                    </button>
                    
                    <!-- Button state debug -->
                    <div class="small text-muted mt-1">
                        Button disabled: @buttonDisabled | File selected: @hasImage | Loading: @isLoading
                    </div>
                    
                    <!-- Debug Toggle -->
                    <div class="form-check mt-3">
                        <input type="checkbox" class="form-check-input" id="debugMode" @bind="debugMode" @bind:after="LoadModels" />
                        <label class="form-check-label" for="debugMode">Debug Mode</label>
                    </div>
                    
                    <!-- Debug Log Panel -->
                    @if (debugLogs.Count > 0)
                    {
                        <div class="mt-3">
                            <label class="form-label fw-bold">Debug Log:</label>
                            <div class="debug-log bg-dark text-light p-2" style="max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;">
                                @foreach (var log in debugLogs)
                                {
                                    <div>@log</div>
                                }
                            </div>
                            <button class="btn btn-sm btn-outline-secondary mt-1" @onclick="() => debugLogs.Clear()">Clear Log</button>
                        </div>
                    }
                </div>
            </div>
        </div>
        
        <!-- Right: Results -->
        <div class="col-md-6">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5>📋 Result</h5>
                    @if (!string.IsNullOrEmpty(resultFen))
                    {
                        <button class="btn btn-sm btn-outline-secondary" @onclick="CopyFen">
                            📋 Copy FEN
                        </button>
                    }
                </div>
                <div class="card-body">
                    @if (!string.IsNullOrEmpty(errorMessage))
                    {
                        <div class="alert alert-danger">@errorMessage</div>
                    }
                    
                    @if (!string.IsNullOrEmpty(resultFen))
                    {
                        <!-- FEN String -->
                        <div class="mb-3">
                            <label class="form-label fw-bold">FEN (piece placement):</label>
                            <input type="text" class="form-control font-monospace" value="@resultFen" readonly />
                        </div>
                        
                        <!-- Full FEN for chess apps -->
                        <div class="mb-3">
                            <label class="form-label fw-bold">Full FEN (for chess apps):</label>
                            <div class="input-group mb-2">
                                <span class="input-group-text">White to move</span>
                                <input type="text" class="form-control font-monospace" value="@GetFullFen("w")" readonly id="fenWhite" />
                                <button class="btn btn-outline-primary" type="button" onclick="copyFenFromInput('fenWhite', this)">
                                    📋 Copy
                                </button>
                            </div>
                            <div class="input-group">
                                <span class="input-group-text">Black to move</span>
                                <input type="text" class="form-control font-monospace" value="@GetFullFen("b")" readonly id="fenBlack" />
                                <button class="btn btn-outline-primary" type="button" onclick="copyFenFromInput('fenBlack', this)">
                                    📋 Copy
                                </button>
                            </div>
                        </div>
                        
                        <!-- Search Games -->
                        <div class="mb-3">
                            <label class="form-label fw-bold">🔍 Find Games with this Position:</label>
                            <div class="d-flex gap-2 flex-wrap align-items-center">
                                <a href="@GetChessComSearchUrl("w")" target="_blank" class="btn btn-success btn-sm">
                                    ♔ Chess.com (White to move)
                                </a>
                                <a href="@GetChessComSearchUrl("b")" target="_blank" class="btn btn-success btn-sm">
                                    ♚ Chess.com (Black to move)
                                </a>
                                <button type="button" class="btn btn-outline-info btn-sm" @onclick="CheckChessComGames" disabled="@isCheckingGames">
                                    @if (isCheckingGames)
                                    {
                                        <span class="spinner-border spinner-border-sm me-1"></span>
                                    }
                                    🔎 Check if games exist
                                </button>
                            </div>
                            
                            <!-- Chess.com search results -->
                            @if (chessComSearchResults.Count > 0)
                            {
                                <div class="mt-2">
                                    @foreach (var result in chessComSearchResults)
                                    {
                                        <div class="badge @(result.GamesFound ? "bg-success" : "bg-secondary") me-2 mb-1">
                                            @(result.Side == "w" ? "♔ White" : "♚ Black"): 
                                            @(result.GamesFound ? "✓ Games found" : "✗ No games")
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                        
                        <!-- FEN Validation -->
                        @if (fenValidation != null)
                        {
                            @if (fenValidation.IsValid && fenValidation.Warnings.Count == 0)
                            {
                                <div class="alert alert-success py-2">
                                    <span>✅ Valid chess position</span>
                                </div>
                            }
                            else if (fenValidation.IsValid && fenValidation.Warnings.Count > 0)
                            {
                                <div class="alert alert-info py-2">
                                    <span>✅ Valid position with notes:</span>
                                    <ul class="mb-0 small">
                                        @foreach (var warning in fenValidation.Warnings)
                                        {
                                            <li>⚠️ @warning</li>
                                        }
                                    </ul>
                                </div>
                            }
                            else
                            {
                                <div class="alert alert-danger py-2">
                                    <span>❌ Invalid position:</span>
                                    <ul class="mb-0 small">
                                        @foreach (var issue in fenValidation.Issues)
                                        {
                                            <li>@issue</li>
                                        }
                                    </ul>
                                    @if (fenValidation.Warnings.Count > 0)
                                    {
                                        <hr class="my-1" />
                                        <span class="small">Warnings:</span>
                                        <ul class="mb-0 small">
                                            @foreach (var warning in fenValidation.Warnings)
                                            {
                                                <li>⚠️ @warning</li>
                                            }
                                        </ul>
                                    }
                                </div>
                            }
                        }
                        
                        <!-- Chess Board Display -->
                        <div class="chess-board-container mb-3">
                            <!-- Piece Palette -->
                            <div class="piece-palette mb-2 text-center">
                                <span class="palette-label">Select piece:</span>
                                @foreach (var p in pieceOptions)
                                {
                                    var pieceKey = p.Key;
                                    <button type="button" 
                                            class="btn btn-sm piece-btn @(selectedPalettePiece == pieceKey ? "active" : "")"
                                            @onclick="() => SelectPalettePiece(pieceKey)"
                                            title="@GetPieceName(pieceKey)">
                                        @p.Value
                                    </button>
                                }
                                @if (!string.IsNullOrEmpty(selectedPalettePiece))
                                {
                                    <span class="ms-2 text-muted small">Click a square to place @GetPieceName(selectedPalettePiece)</span>
                                }
                            </div>
                            
                            <table class="chess-board mx-auto">
                                @for (int row = 0; row < 8; row++)
                                {
                                    var r = row;
                                    <tr>
                                        <td class="rank-label">@(8 - r)</td>
                                        @for (int col = 0; col < 8; col++)
                                        {
                                            var c = col;
                                            var isLight = (r + c) % 2 == 0;
                                            var square = $"{(char)('a' + c)}{8 - r}";
                                            var piece = boardPieces[r, c];
                                            
                                            <td class="@(isLight ? "light" : "dark")" 
                                                @onclick="() => OnSquareClick(square, r, c)"
                                                title="@square: @GetPieceName(piece)">
                                                <span class="piece">@GetPieceUnicode(piece)</span>
                                            </td>
                                        }
                                    </tr>
                                }
                                <tr>
                                    <td></td>
                                    @for (char c = 'a'; c <= 'h'; c++)
                                    {
                                        <td class="file-label">@c</td>
                                    }
                                </tr>
                            </table>
                            
                            <!-- Quick actions -->
                            <div class="mt-2 text-center">
                                <button class="btn btn-sm btn-outline-secondary" @onclick="ClearBoard" title="Clear all pieces">
                                    🗑️ Clear
                                </button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="ResetToOriginal" title="Reset to detected position" disabled="@(originalFen == resultFen)">
                                    ↩️ Reset
                                </button>
                            </div>
                        </div>
                        
                        <!-- Correction Actions -->
                        @if (hasCorrections)
                        {
                            <div class="alert alert-info">
                                <strong>Corrections made:</strong> @string.Join(", ", corrections.Select(c => $"{c.Key}→{c.Value}"))
                            </div>
                            <button class="btn btn-success w-100" @onclick="SubmitCorrections">
                                ✅ Submit Corrections for Training
                            </button>
                        }
                    }
                </div>
            </div>
            
            <!-- Debug Images -->
            @if (debugMode && debugImages != null)
            {
                <div class="card mt-3">
                    <div class="card-header">
                        <h5>🔧 Debug Images</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            @if (!string.IsNullOrEmpty(debugImages.Detection))
                            {
                                <div class="col-4">
                                    <label>Detection</label>
                                    <img src="data:image/png;base64,@debugImages.Detection" class="img-fluid" />
                                </div>
                            }
                            @if (!string.IsNullOrEmpty(debugImages.Warped))
                            {
                                <div class="col-4">
                                    <label>Warped</label>
                                    <img src="data:image/png;base64,@debugImages.Warped" class="img-fluid" />
                                </div>
                            }
                            @if (!string.IsNullOrEmpty(debugImages.Overlay))
                            {
                                <div class="col-4">
                                    <label>Overlay</label>
                                    <img src="data:image/png;base64,@debugImages.Overlay" class="img-fluid" />
                                </div>
                            }
                        </div>
                    </div>
                </div>
            }
        </div>
    </div>
</div>

<style>
    .chess-board {
        border-collapse: collapse;
        border: 2px solid #333;
    }
    .chess-board td {
        width: 45px;
        height: 45px;
        text-align: center;
        vertical-align: middle;
        cursor: pointer;
        user-select: none;
    }
    .chess-board td.light { background-color: #f0d9b5; }
    .chess-board td.dark { background-color: #b58863; }
    .chess-board td:hover:not(.rank-label):not(.file-label) { 
        outline: 3px solid #007bff; 
        outline-offset: -3px;
    }
    .piece { font-size: 32px; pointer-events: none; }
    .rank-label, .file-label {
        font-weight: bold;
        background: transparent !important;
        cursor: default;
    }
    
    /* Piece palette */
    .piece-palette {
        padding: 8px;
        background: #f8f9fa;
        border-radius: 8px;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
        gap: 4px;
    }
    .palette-label {
        font-size: 14px;
        color: #666;
        margin-right: 8px;
    }
    .piece-btn {
        width: 36px;
        height: 36px;
        font-size: 24px;
        padding: 0;
        line-height: 1;
        border: 2px solid #ddd;
        background: white;
    }
    .piece-btn:hover {
        border-color: #007bff;
        background: #e7f1ff;
    }
    .piece-btn.active {
        border-color: #007bff;
        background: #cce5ff;
        box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
    }
</style>

<script>
    // Direct copy function for iOS - must be called from onclick directly (not Blazor)
    function copyFenFromInput(inputId, button) {
        const input = document.getElementById(inputId);
        if (!input) return;
        
        const text = input.value;
        const originalText = button.innerHTML;
        
        // iOS Safari: select and copy from input
        input.focus();
        input.setSelectionRange(0, text.length);
        
        let copied = false;
        
        // Try execCommand first (works in user gesture context)
        try {
            copied = document.execCommand('copy');
        } catch (e) {
            copied = false;
        }
        
        // Try modern clipboard API
        if (!copied && navigator.clipboard) {
            navigator.clipboard.writeText(text).then(function() {
                button.innerHTML = '✓ Copied!';
                setTimeout(function() { button.innerHTML = originalText; }, 2000);
            }).catch(function() {
                button.innerHTML = '⚠ Select & Copy';
                setTimeout(function() { button.innerHTML = originalText; }, 2000);
            });
            return;
        }
        
        if (copied) {
            button.innerHTML = '✓ Copied!';
        } else {
            button.innerHTML = '⚠ Select & Copy';
        }
        
        setTimeout(function() { button.innerHTML = originalText; }, 2000);
    }

    window.copyToClipboardFallback = async function(text) {
        // Try modern clipboard API first
        if (navigator.clipboard && window.isSecureContext) {
            try {
                await navigator.clipboard.writeText(text);
                return { success: true };
            } catch (e) {
                // Fall through to fallback
            }
        }
        
        // Fallback: Create temporary textarea
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            const successful = document.execCommand('copy');
            textArea.remove();
            if (successful) {
                return { success: true };
            }
        } catch (e) {
            textArea.remove();
        }
        
        // Last resort: prompt user
        return { success: false, text: text };
    };
</script>

@code {
    private string? imageBase64;
    private string? imagePreview;
    private string? resultFen;
    private string? originalFen;
    private string? errorMessage;
    private bool isLoading = false;
    private bool debugMode = false;
    private string selectedModel = "";
    
    private string[,] boardPieces = new string[8, 8];
    private string? editingSquare;
    private Dictionary<string, string> corrections = new();
    private bool hasCorrections => corrections.Count > 0;
    private FenValidationResult? fenValidation;
    
    private DebugImagesModel? debugImages;
    private List<ModelInfo> availableModels = new();
    private List<string> debugLogs = new();
    
    private bool buttonDisabled => isLoading || !hasImage;
    
    private int testCounter = 0;
    
    // Chess.com game search
    private bool isCheckingGames = false;
    private List<ChessComSearchResultItem> chessComSearchResults = new();
    
    private Dictionary<string, string> pieceOptions = new()
    {
        { "empty", "·" },
        { "wK", "♔" }, { "wQ", "♕" }, { "wR", "♖" }, { "wB", "♗" }, { "wN", "♘" }, { "wP", "♙" },
        { "bK", "♚" }, { "bQ", "♛" }, { "bR", "♜" }, { "bB", "♝" }, { "bN", "♞" }, { "bP", "♟" }
    };
    
    private string? selectedPalettePiece = "empty";
    
    private void Log(string message)
    {
        var timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
        var logMessage = $"[{timestamp}] {message}";
        debugLogs.Add(logMessage);
        Logger.LogInformation(logMessage);
        Console.WriteLine(logMessage);
    }
    
    private async Task OnAnalyzeClick()
    {
        Log(">>> OnAnalyzeClick triggered! <<<");
        await PredictFen();
    }
    
    private void TestClick()
    {
        testCounter++;
        Log($">>> TestClick! Counter: {testCounter} <<<");
    }

    protected override async Task OnInitializedAsync()
    {
        Log("OnInitializedAsync called");
        Log($"HttpClient BaseAddress: {Http.BaseAddress}");
        InitializeBoard();
    }

    private void InitializeBoard()
    {
        for (int r = 0; r < 8; r++)
            for (int c = 0; c < 8; c++)
                boardPieces[r, c] = "empty";
    }

    private async Task LoadModels()
    {
        if (!debugMode) return;
        
        Log("LoadModels called");
        try
        {
            var url = "/api/chess/models";
            Log($"GET {url}");
            var response = await Http.GetAsync(url);
            Log($"Response: {response.StatusCode}");
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                Log($"Models JSON: {json.Substring(0, Math.Min(200, json.Length))}...");
                availableModels = JsonSerializer.Deserialize<List<ModelInfo>>(json, 
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new();
                
                var best = availableModels.FirstOrDefault(m => m.IsBest);
                if (best != null) selectedModel = best.Name;
                Log($"Loaded {availableModels.Count} models, selected: {selectedModel}");
            }
            else
            {
                Log($"Failed to load models: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Log($"LoadModels error: {ex.Message}");
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        Log("HandleFileSelected called");
        var file = e.File;
        if (file == null)
        {
            Log("No file selected");
            return;
        }

        Log($"File: {file.Name}, Size: {file.Size} bytes, Type: {file.ContentType}");
        
        // Store file reference for later, don't read into memory yet
        selectedFile = file;
        imagePreview = "pending"; // Signal that we have a file but haven't loaded preview
        hasImage = true;
        Log($"File selected, ready for analysis");
        
        // Clear previous results
        resultFen = null;
        errorMessage = null;
        fenValidation = null;
        corrections.Clear();
        InitializeBoard();
    }
    
    private IBrowserFile? selectedFile;
    private bool hasImage = false;

    private async Task PredictFen()
    {
        Log("=== PredictFen STARTED ===");
        
        if (selectedFile == null)
        {
            Log("ERROR: No file selected");
            return;
        }
        
        isLoading = true;
        errorMessage = null;
        StateHasChanged();
        
        try
        {
            // Read file now (only when needed for API call)
            Log($"Reading file: {selectedFile.Name}, Size: {selectedFile.Size}");
            
            // Read all bytes properly using MemoryStream
            using var memoryStream = new MemoryStream();
            await selectedFile.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024).CopyToAsync(memoryStream);
            var buffer = memoryStream.ToArray();
            Log($"Bytes read: {buffer.Length}");
            
            var base64Data = Convert.ToBase64String(buffer);
            Log($"File read, base64 length: {base64Data.Length}");
            
            var query = debugMode ? $"?debug=true&model={selectedModel}" : "";
            var url = $"/api/chess/predict/base64{query}";
            Log($"POST {url}");
            Log($"HttpClient.BaseAddress = {Http.BaseAddress}");
            
            var payload = JsonSerializer.Serialize(new { image = base64Data });
            Log($"Payload size: {payload.Length} chars");
            
            var content = new StringContent(payload, System.Text.Encoding.UTF8, "application/json");
            
            Log("Sending HTTP request...");
            var response = await Http.PostAsync(url, content);
            Log($"Response received: {response.StatusCode}");
            
            var json = await response.Content.ReadAsStringAsync();
            Log($"Response body length: {json.Length}");
            Log($"Response body (first 500 chars): {json.Substring(0, Math.Min(500, json.Length))}");
            
            var result = JsonSerializer.Deserialize<PredictionResult>(json, 
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
            
            if (result?.Success == true)
            {
                Log($"SUCCESS! FEN: {result.Fen}");
                resultFen = result.Fen;
                originalFen = result.Fen;
                fenValidation = ValidateFen(resultFen ?? "");
                Log($"Validation: {(fenValidation.IsValid ? "Valid" : "Invalid")} - {fenValidation.Issues.Count} issues");
                ParseBoardFromResult(result.Board);
                debugImages = result.DebugImages;
                
                // Store for preview after success
                imageBase64 = base64Data;
                imagePreview = $"data:{selectedFile.ContentType};base64,{base64Data}";
            }
            else
            {
                Log($"FAILED: {result?.Error ?? "Unknown error"}");
                errorMessage = result?.Error ?? "Unknown error";
            }
        }
        catch (Exception ex)
        {
            Log($"EXCEPTION: {ex.GetType().Name}: {ex.Message}");
            Log($"Stack: {ex.StackTrace?.Substring(0, Math.Min(300, ex.StackTrace?.Length ?? 0))}");
            errorMessage = $"Error: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            Log("=== PredictFen COMPLETED ===");
            StateHasChanged();
        }
    }

    private void ParseBoardFromResult(string[][]? board)
    {
        if (board == null) return;
        
        for (int r = 0; r < 8 && r < board.Length; r++)
        {
            for (int c = 0; c < 8 && c < board[r].Length; c++)
            {
                boardPieces[r, c] = board[r][c] ?? "empty";
            }
        }
    }

    private string GetPieceUnicode(string piece)
    {
        if (piece == "empty") return "";
        return pieceOptions.TryGetValue(piece, out var unicode) ? unicode : "";
    }
    
    private string GetPieceName(string piece) => piece switch
    {
        "empty" => "Empty",
        "wK" => "White King", "wQ" => "White Queen", "wR" => "White Rook",
        "wB" => "White Bishop", "wN" => "White Knight", "wP" => "White Pawn",
        "bK" => "Black King", "bQ" => "Black Queen", "bR" => "Black Rook",
        "bB" => "Black Bishop", "bN" => "Black Knight", "bP" => "Black Pawn",
        _ => piece
    };
    
    private void SelectPalettePiece(string piece)
    {
        selectedPalettePiece = piece;
    }
    
    private void OnSquareClick(string square, int row, int col)
    {
        if (string.IsNullOrEmpty(selectedPalettePiece)) return;
        
        var oldPiece = boardPieces[row, col];
        if (oldPiece != selectedPalettePiece)
        {
            boardPieces[row, col] = selectedPalettePiece;
            corrections[square] = selectedPalettePiece;
            resultFen = GenerateFenFromBoard();
            fenValidation = ValidateFen(resultFen ?? "");
            chessComSearchResults.Clear(); // Clear old search results
            StateHasChanged();
        }
    }
    
    private void ClearBoard()
    {
        for (int r = 0; r < 8; r++)
            for (int c = 0; c < 8; c++)
                boardPieces[r, c] = "empty";
        
        resultFen = GenerateFenFromBoard();
        fenValidation = ValidateFen(resultFen ?? "");
        corrections.Clear();
        corrections["cleared"] = "all";
        chessComSearchResults.Clear(); // Clear old search results
        StateHasChanged();
    }
    
    private void ResetToOriginal()
    {
        if (string.IsNullOrEmpty(originalFen)) return;
        
        resultFen = originalFen;
        ParseFenToBoard(originalFen);
        fenValidation = ValidateFen(resultFen ?? "");
        corrections.Clear();
        chessComSearchResults.Clear(); // Clear old search results
        StateHasChanged();
    }
    
    private void ParseFenToBoard(string fen)
    {
        var piecePlacement = fen.Split(' ')[0];
        var ranks = piecePlacement.Split('/');
        
        for (int r = 0; r < 8 && r < ranks.Length; r++)
        {
            int col = 0;
            foreach (char c in ranks[r])
            {
                if (char.IsDigit(c))
                {
                    for (int i = 0; i < (c - '0') && col < 8; i++)
                        boardPieces[r, col++] = "empty";
                }
                else
                {
                    boardPieces[r, col++] = FenCharToPiece(c);
                }
            }
        }
    }
    
    private string FenCharToPiece(char c) => c switch
    {
        'K' => "wK", 'Q' => "wQ", 'R' => "wR", 'B' => "wB", 'N' => "wN", 'P' => "wP",
        'k' => "bK", 'q' => "bQ", 'r' => "bR", 'b' => "bB", 'n' => "bN", 'p' => "bP",
        _ => "empty"
    };

    private void StartEditing(string square, int row, int col)
    {
        editingSquare = editingSquare == square ? null : square;
    }

    private void UpdatePiece(string square, int row, int col, string? newPiece)
    {
        if (string.IsNullOrEmpty(newPiece)) return;
        
        var oldPiece = boardPieces[row, col];
        if (oldPiece != newPiece)
        {
            boardPieces[row, col] = newPiece;
            corrections[square] = newPiece;
            resultFen = GenerateFenFromBoard();
            fenValidation = ValidateFen(resultFen ?? "");
        }
        editingSquare = null;
    }

    private string GenerateFenFromBoard()
    {
        var rows = new List<string>();
        for (int r = 0; r < 8; r++)
        {
            var row = "";
            int empty = 0;
            for (int c = 0; c < 8; c++)
            {
                var piece = boardPieces[r, c];
                if (piece == "empty")
                {
                    empty++;
                }
                else
                {
                    if (empty > 0) { row += empty; empty = 0; }
                    row += PieceToFenChar(piece);
                }
            }
            if (empty > 0) row += empty;
            rows.Add(row);
        }
        return string.Join("/", rows);
    }

    private string PieceToFenChar(string piece) => piece switch
    {
        "wP" => "P", "wN" => "N", "wB" => "B", "wR" => "R", "wQ" => "Q", "wK" => "K",
        "bP" => "p", "bN" => "n", "bB" => "b", "bR" => "r", "bQ" => "q", "bK" => "k",
        _ => ""
    };

    private async Task SubmitCorrections()
    {
        try
        {
            var payload = JsonSerializer.Serialize(new
            {
                originalFen = originalFen,
                correctedFen = resultFen,
                image = imageBase64,
                correctedSquares = corrections
            });
            var content = new StringContent(payload, System.Text.Encoding.UTF8, "application/json");
            
            var response = await Http.PostAsync("/api/chess/feedback", content);
            
            if (response.IsSuccessStatusCode)
            {
                corrections.Clear();
                StateHasChanged();
            }
        }
        catch { /* ignore */ }
    }

    private async Task CopyFen()
    {
        await CopyToClipboard(resultFen ?? "");
    }

    private async Task CopyWhiteFen()
    {
        await CopyToClipboard(GetFullFen("w"));
    }

    private async Task CopyBlackFen()
    {
        await CopyToClipboard(GetFullFen("b"));
    }

    private string GetFullFen(string sideToMove)
    {
        if (string.IsNullOrEmpty(resultFen)) return "";
        
        // Build full FEN: pieces side castling enpassant halfmove fullmove
        // We can try to infer castling rights from piece positions
        var castling = InferCastlingRights();
        
        // Format: [pieces] [side] [castling] [enpassant] [halfmove] [fullmove]
        return $"{resultFen} {sideToMove} {castling} - 0 1";
    }
    
    private string GetChessComSearchUrl(string sideToMove)
    {
        var fullFen = GetFullFen(sideToMove);
        if (string.IsNullOrEmpty(fullFen)) return "#";
        
        var encodedFen = Uri.EscapeDataString(fullFen);
        return $"https://www.chess.com/games/search?fen={encodedFen}";
    }
    
    private string GetLichessSearchUrl(string sideToMove)
    {
        var fullFen = GetFullFen(sideToMove);
        if (string.IsNullOrEmpty(fullFen)) return "#";
        
        // Lichess uses analysis board with FEN parameter
        var encodedFen = Uri.EscapeDataString(fullFen);
        return $"https://lichess.org/analysis?fen={encodedFen}";
    }
    
    private async Task CheckChessComGames()
    {
        if (string.IsNullOrEmpty(resultFen)) return;
        
        isCheckingGames = true;
        chessComSearchResults.Clear();
        StateHasChanged();
        
        try
        {
            // Check both white and black to move
            foreach (var side in new[] { "w", "b" })
            {
                var fullFen = GetFullFen(side);
                var encodedFen = Uri.EscapeDataString(fullFen);
                
                var response = await Http.GetAsync($"/api/chess/chess-com-search?fen={encodedFen}");
                if (response.IsSuccessStatusCode)
                {
                    var json = await response.Content.ReadAsStringAsync();
                    var result = JsonSerializer.Deserialize<ChessComSearchResponse>(json, 
                        new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    
                    chessComSearchResults.Add(new ChessComSearchResultItem
                    {
                        Side = side,
                        GamesFound = result?.GamesFound ?? false,
                        Message = result?.Message
                    });
                }
                else
                {
                    chessComSearchResults.Add(new ChessComSearchResultItem
                    {
                        Side = side,
                        GamesFound = false,
                        Message = "Error checking"
                    });
                }
            }
        }
        catch (Exception ex)
        {
            Log($"Error checking Chess.com: {ex.Message}");
        }
        finally
        {
            isCheckingGames = false;
            StateHasChanged();
        }
    }

    private string InferCastlingRights()
    {
        // Check if kings and rooks are on starting squares
        var rights = "";
        
        // White: King on e1 (row 7, col 4)
        if (boardPieces[7, 4] == "wK")
        {
            // White kingside: Rook on h1 (row 7, col 7)
            if (boardPieces[7, 7] == "wR") rights += "K";
            // White queenside: Rook on a1 (row 7, col 0)
            if (boardPieces[7, 0] == "wR") rights += "Q";
        }
        
        // Black: King on e8 (row 0, col 4)
        if (boardPieces[0, 4] == "bK")
        {
            // Black kingside: Rook on h8 (row 0, col 7)
            if (boardPieces[0, 7] == "bR") rights += "k";
            // Black queenside: Rook on a8 (row 0, col 0)
            if (boardPieces[0, 0] == "bR") rights += "q";
        }
        
        return string.IsNullOrEmpty(rights) ? "-" : rights;
    }

    private string? clipboardMessage;
    
    private async Task CopyToClipboard(string text)
    {
        try
        {
            var result = await JSRuntime.InvokeAsync<ClipboardResult>("copyToClipboardFallback", text);
            if (result.Success)
            {
                clipboardMessage = "✓ Copied!";
            }
            else
            {
                // Show the text in an alert for manual copying on iOS
                clipboardMessage = "Select & copy: " + text;
            }
            StateHasChanged();
            await Task.Delay(3000);
            clipboardMessage = null;
            StateHasChanged();
        }
        catch
        {
            clipboardMessage = "Long-press to copy: " + text;
            StateHasChanged();
        }
    }

    private class ClipboardResult
    {
        public bool Success { get; set; }
        public string? Text { get; set; }
    }

    // Model classes
    public class PredictionResult
    {
        public bool Success { get; set; }
        public string? Fen { get; set; }
        public string[][]? Board { get; set; }
        public string? Error { get; set; }
        public DebugImagesModel? DebugImages { get; set; }
    }

    public class DebugImagesModel
    {
        public string? Detection { get; set; }
        public string? Warped { get; set; }
        public string? Overlay { get; set; }
    }

    public class ModelInfo
    {
        public string Name { get; set; } = "";
        public string Type { get; set; } = "";
        public string? Accuracy { get; set; }
        public bool IsBest { get; set; }
    }

    // FEN Validation
    public class FenValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Issues { get; set; } = new();
        public List<string> Warnings { get; set; } = new();
    }

    private FenValidationResult ValidateFen(string fen)
    {
        var result = new FenValidationResult { IsValid = true };
        
        if (string.IsNullOrWhiteSpace(fen))
        {
            result.IsValid = false;
            result.Issues.Add("FEN string is empty");
            return result;
        }

        // Take only the piece placement part (before any space)
        var piecePlacement = fen.Split(' ')[0];
        var ranks = piecePlacement.Split('/');

        // Must have 8 ranks
        if (ranks.Length != 8)
        {
            result.IsValid = false;
            result.Issues.Add($"Expected 8 ranks, found {ranks.Length}");
            return result;
        }

        // Count all pieces
        int whiteKings = 0, blackKings = 0;
        int whiteQueens = 0, blackQueens = 0;
        int whiteRooks = 0, blackRooks = 0;
        int whiteBishops = 0, blackBishops = 0;
        int whiteKnights = 0, blackKnights = 0;
        int whitePawns = 0, blackPawns = 0;
        var validPieces = "KQRBNPkqrbnp";
        
        // Track bishop square colors
        bool whiteBishopOnLight = false, whiteBishopOnDark = false;
        bool blackBishopOnLight = false, blackBishopOnDark = false;

        for (int rankIdx = 0; rankIdx < 8; rankIdx++)
        {
            var rank = ranks[rankIdx];
            int col = 0;

            foreach (char c in rank)
            {
                if (char.IsDigit(c))
                {
                    int emptyCount = c - '0';
                    if (emptyCount < 1 || emptyCount > 8)
                    {
                        result.IsValid = false;
                        result.Issues.Add($"Invalid empty square count '{c}' in rank {8-rankIdx}");
                    }
                    col += emptyCount;
                }
                else if (validPieces.Contains(c))
                {
                    bool isLightSquare = (rankIdx + col) % 2 == 0;
                    
                    // Count pieces and track bishops
                    switch (c)
                    {
                        case 'K': whiteKings++; break;
                        case 'k': blackKings++; break;
                        case 'Q': whiteQueens++; break;
                        case 'q': blackQueens++; break;
                        case 'R': whiteRooks++; break;
                        case 'r': blackRooks++; break;
                        case 'B': 
                            whiteBishops++; 
                            if (isLightSquare) whiteBishopOnLight = true; else whiteBishopOnDark = true;
                            break;
                        case 'b': 
                            blackBishops++; 
                            if (isLightSquare) blackBishopOnLight = true; else blackBishopOnDark = true;
                            break;
                        case 'N': whiteKnights++; break;
                        case 'n': blackKnights++; break;
                        case 'P': whitePawns++; break;
                        case 'p': blackPawns++; break;
                    }
                    
                    // Check for pawns on 1st or 8th rank (illegal)
                    if ((c == 'P' || c == 'p') && (rankIdx == 0 || rankIdx == 7))
                    {
                        result.IsValid = false;
                        result.Issues.Add($"Pawn on rank {8-rankIdx} is illegal");
                    }
                    
                    col++;
                }
                else
                {
                    result.IsValid = false;
                    result.Issues.Add($"Invalid character '{c}' in rank {8-rankIdx}");
                }
            }

            if (col != 8)
            {
                result.IsValid = false;
                result.Issues.Add($"Rank {8-rankIdx} has {col} squares (expected 8)");
            }
        }

        // === CRITICAL VALIDATIONS (make position invalid) ===
        
        // King validation - exactly one of each required
        if (whiteKings == 0)
        {
            result.IsValid = false;
            result.Issues.Add("Missing white king ♔");
        }
        else if (whiteKings > 1)
        {
            result.IsValid = false;
            result.Issues.Add($"Too many white kings: {whiteKings} (max 1)");
        }

        if (blackKings == 0)
        {
            result.IsValid = false;
            result.Issues.Add("Missing black king ♚");
        }
        else if (blackKings > 1)
        {
            result.IsValid = false;
            result.Issues.Add($"Too many black kings: {blackKings} (max 1)");
        }
        
        // Pawn count - max 8 each
        if (whitePawns > 8)
        {
            result.IsValid = false;
            result.Issues.Add($"Too many white pawns: {whitePawns} (max 8)");
        }
        if (blackPawns > 8)
        {
            result.IsValid = false;
            result.Issues.Add($"Too many black pawns: {blackPawns} (max 8)");
        }

        // === WARNINGS (unusual but technically possible with promotions) ===
        
        // Calculate max possible promoted pieces (8 pawns - current pawns = max promotions)
        int whitePossiblePromotions = 8 - whitePawns;
        int blackPossiblePromotions = 8 - blackPawns;
        
        // Extra pieces beyond starting count
        int whiteExtraQueens = Math.Max(0, whiteQueens - 1);
        int whiteExtraRooks = Math.Max(0, whiteRooks - 2);
        int whiteExtraBishops = Math.Max(0, whiteBishops - 2);
        int whiteExtraKnights = Math.Max(0, whiteKnights - 2);
        int whiteTotalExtra = whiteExtraQueens + whiteExtraRooks + whiteExtraBishops + whiteExtraKnights;
        
        int blackExtraQueens = Math.Max(0, blackQueens - 1);
        int blackExtraRooks = Math.Max(0, blackRooks - 2);
        int blackExtraBishops = Math.Max(0, blackBishops - 2);
        int blackExtraKnights = Math.Max(0, blackKnights - 2);
        int blackTotalExtra = blackExtraQueens + blackExtraRooks + blackExtraBishops + blackExtraKnights;
        
        // Check if promotions exceed what's possible
        if (whiteTotalExtra > whitePossiblePromotions)
        {
            result.Warnings.Add($"White has {whiteTotalExtra} extra pieces but only {whitePossiblePromotions} possible promotions");
        }
        if (blackTotalExtra > blackPossiblePromotions)
        {
            result.Warnings.Add($"Black has {blackTotalExtra} extra pieces but only {blackPossiblePromotions} possible promotions");
        }
        
        // Two bishops on same color is unusual (possible via promotion, but rare)
        if (whiteBishops >= 2 && whiteBishopOnLight && !whiteBishopOnDark)
        {
            result.Warnings.Add("White has 2+ bishops, all on light squares");
        }
        if (whiteBishops >= 2 && whiteBishopOnDark && !whiteBishopOnLight)
        {
            result.Warnings.Add("White has 2+ bishops, all on dark squares");
        }
        if (blackBishops >= 2 && blackBishopOnLight && !blackBishopOnDark)
        {
            result.Warnings.Add("Black has 2+ bishops, all on light squares");
        }
        if (blackBishops >= 2 && blackBishopOnDark && !blackBishopOnLight)
        {
            result.Warnings.Add("Black has 2+ bishops, all on dark squares");
        }
        
        // Total piece count check (max 16 per side)
        int whiteTotalPieces = whiteKings + whiteQueens + whiteRooks + whiteBishops + whiteKnights + whitePawns;
        int blackTotalPieces = blackKings + blackQueens + blackRooks + blackBishops + blackKnights + blackPawns;
        
        if (whiteTotalPieces > 16)
        {
            result.IsValid = false;
            result.Issues.Add($"White has {whiteTotalPieces} pieces (max 16)");
        }
        if (blackTotalPieces > 16)
        {
            result.IsValid = false;
            result.Issues.Add($"Black has {blackTotalPieces} pieces (max 16)");
        }

        return result;
    }
    
    // Chess.com search models
    public class ChessComSearchResponse
    {
        public bool Success { get; set; }
        public bool GamesFound { get; set; }
        public string? SearchUrl { get; set; }
        public string? Message { get; set; }
        public string? Error { get; set; }
    }
    
    public class ChessComSearchResultItem
    {
        public string Side { get; set; } = "";
        public bool GamesFound { get; set; }
        public string? Message { get; set; }
    }
}

